

Dv(U)(xi) = { variables that needs to be bang for xi to be bang }  or bottom

Dv({}) = x |-> {x}

Dv( set(x,a); U )(xi) = IF exists y in Av(a) cap Dv(U)(xi) then bottom
                        ELSE IF x in Dv(U)(xi) THEN  Dv(U)(xi) cup Ov(a)   (  - {x}  ??)
                        ELSE Dv(U)(xi)
Dv( set(x,U); e ) = Dv(U)
Dv( if (x) then a else U) = Dv(U)

Lv( set(x,a); U ) = Lv(U) cup IF x in Lv(U) THEN Av(a) ELSE emptyset
Lv( set(x,U); e ) = Fv(e) cup Lv(U)
Lv( {} ) = emptyset





Parser : PVS code -> internal representation
Inverse transformation possible ?


Translation pvs -> ???
C : no lambda term...
better aim at functionnal languages... (ML, C++ ) rather than imperative
Clean : only expr ?


Translation  Coq/?? -> PVS

Need a Coq/?? parser
    (written/proved in PVS ? written in OCaml ? use Coq parser? )

Parsing Coq -> Translating Coq objects to PVS objects -> Generate PVS code
Parsing Coq -> Generate PVS code from Coq objects
Parsing Coq to PVS object -> Generate PVS code

Writing XML Parser (PVS ? Lisp ?)
Coq -> Parsed in OCaml to -> XML -> Parsed to PVS


Absence of mutable type...

Destructive functions
Lisp generated by PVS can't be runned efficiently (errors, non destructive functions, ...)


PVS -> Curry Howard isomorphism ?


What about Java ?
PVS to Java already exists  (use Why)
