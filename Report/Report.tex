\documentclass[12pt,a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
% \usepackage[francais]{babel}

\usepackage[left=1.5cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{graphicx}

% --- CSL part
\usepackage{natbib}
\input{includes/pvstex}
\usepackage{includes/makebnf}


\usepackage[space]{grffile}

% --- Partie code
\usepackage{listings}
\lstset{language=C,
        showstringspaces=false,
        basicstyle=\footnotesize\ttfamily,
        captionpos=b,
        stepnumber=1,
        keywordstyle=\bfseries\color{green!40!black},
        commentstyle=\itshape\color{purple!40!black},
        identifierstyle=\color{blue},
        stringstyle=\color{red}}

\newcommand{\cl}[1]{\texttt{#1}}

% --- Parti math. (app.)
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{remark}[theorem]{Remark}

% Mathematic abbreviations

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Esp}{\mathbb{E}}
%\newcommand{\E}{\mathbb{E}} % Si tu l'utilise beaucoup
\newcommand{\Prob}{\mathbb{P}}
%\newcommand{\P}{\mathbb{P}} % Si tu l'utilise beaucoup

\newcommand{\mpzt}{\texttt{mpz\_t}}
\newcommand{\mpqt}{\texttt{mpq\_t}}

\newcommand{\mut}{  \textbf{ mutable } }
\newcommand{\nmut}{ \textbf{ non-mutable } }
\newcommand{\bang}{ \textbf{ mutable } }
\newcommand{\safe}{ \textbf{ safe } }
\newcommand{\dupl}{ \textbf{ duplicated } }



\title{
\vspace{-3cm}
\normalsize
\begin{tabular}{p{15cm}}
ÉCOLE POLYTECHNIQUE \\
PROMOTION X2011 \\
Férey Gaspard
\end{tabular}
\vspace{3cm}
\begin{center}
\includegraphics[height=3cm]{pictures/logo.png}
\end{center}
\vspace{1cm}
\large
\begin{center}
RAPPORT DE STAGE D'OPTION SCIENTIFIQUE\\
\vspace{1cm}
{\Huge Titre}\\
\vspace{1cm}
NON CONFIDENTIEL
\end{center}
\vspace{3cm}
\normalsize
\begin{tabular}{p{6cm} p{10cm}}
Option :                  & INFORMATIQUE \\
Champ de l'option :       & Math-Informatique \\
Directeur de l'option :   & Olivier Bournez \\
Directeur de stage :      & Olivier Bournez \\
Dates du stage :          & 7 avril - 22 aout 2014\\
Nom et adresse de l'organisme :  & SRI International \\
                          & Computer Science Laboratory (CSL) \\
                          & 333 Ravenswood Avenue \\
                          & Menlo Park, CA 94025-3493 \\
                          & United States
\end{tabular}
}

\begin{document}

\maketitle

\vspace{2.2in}
\begin{abstract}
SAT solvers can generate proofs that justify their final result.
This report presents a verified program that checks if the generated proofs are valid. The checker is written and
proved in PVS. In order to execute it, Lisp code is automatically generated. 
We describe a trusted kernel called the Kernel of Truth. 
Finally, we prove that it exists a valid kernel proof corresponding to any valid checker proof. 
This demonstrates that the checker is a safe extension of the kernel.
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

Before starting, I would like to thank Dr. Natarajan Shankar for making this internship possible and for the many enlightning conversations we had.

Sam Owre was

giving me the chance to work on this project and for helping me
throughout all my internship. I also had great help from Sam Owre and from Dr. Bruno Dutertre. \\




\subsection{PVS Overview}

PVS  (Prototype Verification System) is an environment for specification and proving. The main purpose of PVS is to provide 
formal support for conceptualization and debugging in the early stages of the lifecycle of the design
of hardware or software systems. In these stages, both the requirements and designs are expressed in abstract
terms that are not necessarily executable. The best way to analyze such an abstract specification is by 
attempting proofs of desirable consequences of the specification. Subtle errors revealed by trying to prove
the properties are costly to detect and correct at later stages of the design lifecycle.
\\The specification language of PVS is built on higher-order logic (functions can be treated like
primitive types: functions can take functions as arguments and return them as values, quantification
can be applied to function variables. Specifications can be constructed using definitions and axioms




\subsection{The HACMS Project}


\subsection{Translating PVS}
\subsubsection{Parsing and typechecking PVS}
These two task we leave to PVS native parser and typechecker.

The parser generates objects representing the expressions of the theory.

We only convert a subset of PVS.
This subset is defined by a subset of expression objects we can translate.
The objective is, of course, to be able to translate the maximum of (if not all) PVS expression objects.

\subsubsection{Other translator}
- Common Lisp (native)
- Clean
- Yices




\section{PVS syntax}

\subsection{PVS Syntax}

In Figure~\ref{fig:PVSsyntax}, we describe the subset of PVS we translate to C.

In Figure~\ref{fig:PVS-CLOS}, we describe the object system used to represent them in Common Lisp. Some classes and some slots in the classes are voluntarily ommitted. For a full description of PVS parser representation, refer to \cite{PVS:api}.




\subsection{Translator architecture}

Describe here the Lisp functions and data structures

Skeleton

Expected input

Output objects

Assertions that we (try to) maintain


The translation from PVS to C is made following five main steps:
\begin{itemize}
\item Typechecking: The PVS typechecker perform a type analysis on the PVS code to associate a PVS type to each expression. This might generates some proof obligations (TCC).
\item Lexical and syntactic analysis: The PVS parser transforms PVS code into a CLOS internal representation.
\item Translation: The translator generates a different representation from PVS expressions and functions declarations.
Typically, an expression $e$ is translated into a tuple of four elements $(t,n,i,d)$, where $t$ represents a C type used to describe the expression, $n$ is a string representing the expression, $i$ is a list of instructions supposed to be executed prior to using $n$ (initialisation of $n$) and $d$ is a list of instructions to be executed when $n$ isn't needed anymore (destruction of $n$).
\item Analysis and optimizations: We run several analysis on the code representation. In particular, we determine the adapted C types, we try to avoid unnecessary copies and non destructive updates when possible using flow analysis and an enriched type system.
\item Code generation: C code is generated (.c and .h files) and can be compiled using gcc and executed when linked with the garbage collector and the GMP library. 
\end{itemize}

We first define a function $T$ to translate an expression $e$.
$$ T(e) = ( \ T^t(e) \ , \ T^n(e) \ , \ T^i(e) \ , \ T^d(e) \ ) $$

\begin{figure}[h!]
\begin{eqnarray*}
T(\cl{2}) &= (& \cl{int}, "2", [], []) \\
T(\cl{4294967296}) &= (& \cl{mpz\_t}, \ ? \ , \\
&& [ \cl{mpz\_init(?);} \ | \\
&& \ \cl{mpz\_set\_str(?, "4294967296");} ],\\
&& [ \cl{mpz\_clear(?);} ]) \\
T(\cl{lambda(x:below(10)):x}) &= (& \cl{int*}, \ ? \ , \\
&& [ \cl{? = malloc(10 * sizeof(int));} \ | \\
&& \ \cl{int i;} | \\
&& \ \cl{for(i = 0; i < 10; i++) }\\
&& \ \ \ \cl{?[i] = i;}  ]\\
&& [ \cl{free(?);} ])
\end{eqnarray*}
\caption{Translation examples: number expressions}
\end{figure}

It may occur that $T^n(e) = ?$. In that case, the symbol $?$ appearing in $T^i(e)$ and $T^d(e)$ needs to be replaced by a proper variable name.\\

We then define two other operators:
\begin{itemize}
\item $R$ wich take an expression and a type and may add an extra conversion in the instructions to make sure its result has the expected type. Also the result of this function has a proper name.
\item $S$ which take an expression, a type and a name. It makes sure that the given variable (type + name) is set to a value representing the expression.
\end{itemize}




\subsection{A few translation rules}

Translation rules :




\begin{lstlisting}
number-expr "2"
(C-int, "2", [], [])

number-expr "12315468453213"
(C-mpz, nil,
        [mpz_t ~a; | mpz_t_init("12315468453213"); ],
        [mpz_clear ~a;])

application "f(e1, e2)"
(C-mpz, nil,
       [ instr(e1) | instr(e2)
                   | mpz(~a); | f(~a, e1, e2) ]
       [mpz_clear(~a);]
\end{lstlisting}



\section{PVS type system}

\subsection{PVS Types}
A PVS theory can be typechecked using the emacs interface \cl{M-x typecheck} or calling the Lisp function \cl{(tc name-theory)}. This first runs the PVS parser on the code and generates CLOS objects to represent it. Then, the PVS typechecker is run on this internal representation of the theory and tries to give a type to all expressions generating TCC when needed.\\

Here we describe how PVS types are represented in 
Lisp.

Figure~\ref{fig:PVS-types} \\
Figure~\ref{fig:PVS-CLOS-types}


\subsection{Translating types}
PVS types:\\
boolean, number, number\_field, real, 
rational, integer, $A \rightarrow B$, restricted types
$\text{below}(10) := \{ x:\text{int} | 0 \leq x < 10 \} $)  \\
enum
datatype


This requires a type analysis to decide on the type of a PVS expression. For example the PVS \cl{int} type can be represented by the \cl{int}, \cl{unsigned long} or \cl{mpz\_t} C types. In that case, we study the range of the expression to decide which types are allowed to represent it. Then we take the context in which the expression appears to decide. For instance in
\begin{lstlisting}
incr(x:below(10)):int = x+1
\end{lstlisting}
the \cl{x} expression, result of the function \cl{incr} can always be represented by an \cl{int} or \cl{unsigned long} in C but we choose here to represent it using a \cl{mpz\_t}.

Auxiliary type system :
C-type with a flag : mutable (meaning that the expression it describes only has one pointer pointing to it.

\begin{lstlisting}
int a = 2;     a : int[mutable]
int* a = malloc( 10 * sizeof(int*) );  
\end{lstlisting}

destructive addition:

\begin{lstlisting}
d_add(*mpz_t res, mpz_t[mutable] a, long b) {
  mpz_add(a, a, b);
  (*res) = a;
}
\end{lstlisting}

Rq : \cl{d\_add} is given a mutable \mpzt, meaning that it can modify it and is responsible for freeing it.
It is also responsible for allocating memory for the result.
Here it uses the memory to assign res.



Use an auxiliary language :

\begin{lstlisting}
( expr, C-type[mutable] )
\end{lstlisting}

Conversions and copies create mutables types (at a cost) :
\cl{a[mutable]\_from\_b}

\cite{fillcomp}







C types:\\
\cite{huss2004c}
\begin{lstlisting}[caption=C types]
// integer and floating point types
[unsigned] char, int, long, double
type*  //arrays
char*  // strings
struct types  // structures with fields
enum types
short int, float, union, size_t // etc...
\end{lstlisting}


Translation rules :

\begin{figure}[h!]
\begin{tabular}{|l|l|}
\hline
\cl{subrange(a, b)} &
\begin{lstlisting}
int            // if small enough
unsigned long  // if too big or needed for function call
mpz_t          // else
\end{lstlisting} \\ \hline
\cl{int} &
\begin{lstlisting}
mpz_t
\end{lstlisting} \\ \hline
\cl{rat} &
\begin{lstlisting}
mpq_t
\end{lstlisting} \\ \hline
\cl{[below(a) -> Type]} &
\begin{lstlisting}
(Ctype)*
\end{lstlisting} \\ \hline
\cl{T : TYPE = [\# $x_i$ : $t_i$ \#]}  &
\begin{lstlisting}
struct CT {
   ...
   Ct_i x_i;
   ...
}; // These types must be declared
\end{lstlisting} \\ \hline
\cl{[Range -> Domain]} & C closure parameterized by the \cl{Domain} return type.\\ \hline
\end{tabular}
\caption{Translation rules for PVS types}
\end{figure}









We can only translate a subset of all PVS types.
What's missing ?




\subsection{Translating PVS syntax}


We can only translate a subset of PVS syntax.
What's missing ?



\subsection{Using a representation of the C language}

Figure~\ref{fig:Csyntax}








\section{Update expressions}


 It is a complicated problem to decide while compiling a functionnal language whether an update expression should be translated into a destructive or non destructive update in the target imperative language.\\

Update expressions are represented by PVS as \texttt{update-
expr} objects.

$$ E := \texttt{ t with [ e1 := e2 ] } $$

Problem :
\cl{t} is an expression typed as a function. Therefore it might be represented in C as an array (if domain type is \cl{below($n$)}.
We want to know if we can update \cl{t} in place to obtain a C object representing $E$ or if we have to make a copy of \cl{t}.


We consider a few solutions to this problem.


\subsection{Pointer counting}

Several systems rely on a reference couting garbage collectors. This family of garbage collectors has many advantages \cite{jonesgarbage}. Along with its simplicity and the instantaneity of garbage identification, the one we are interested in is the possibility to determine when a local variable is the only pointer to a complex data structure. In that case, at the cost of a simple test, we can avoid copies and perform destructive updates. \\

The idea is to keep track of the number of pointers pointing to an array or a struct. If an array is referenced in several portions of the code (nested reference in other data structure, local variable in calling function, ...) then we mus be able, using the pointer counter, to perform all updates non destructively to avoid inconsistency.\\

We implement a very simple "Reference Counting Garbage Collector" as described in \cite{jonesgarbage} and integrate it to the C code generated.\\

The GC consists on a hashtable of pointer counters that we maintain during the execution of the code. Each pointer to data allocated on the heap is a key in the hastable to which we associate an int counter as value. We then make sure that all memory allocations in the code make a call to the GC to "declare" the new memory.

\begin{tabular}{|p{5cm}|p{11cm}|}
\hline
\begin{lstlisting}
T* a = malloc(
     10 * sizeof(int));
\end{lstlisting} & \begin{lstlisting}
T* a = (T*) GC_malloc(10 * sizeof(int));
\end{lstlisting}
All memory allocation are handled by the GC to make sure every new reference on the heap is in the reference table and has a pointer counter associated to it.
\\ \hline
\begin{lstlisting}
free(a);
\end{lstlisting} & \begin{lstlisting}
GC_free(a);
\end{lstlisting}
This will decrement the reference counter on \cl{a} and might free it if this counter is now 0. \\ \hline
\begin{lstlisting}
T* a = b;
\end{lstlisting} & \begin{lstlisting}
T* a = (T*) GC( b );
\end{lstlisting}
The reference count on \cl{b} is incremented to represent that the local variable \cl{a} now also points to the structure \cl{b} points to.\\ \hline
\begin{lstlisting}
t[0] = b;
\end{lstlisting} & \begin{lstlisting}
GC_free( t[0] );
t[0] = (T*) GC( b );
\end{lstlisting}
This time, we also make sure the reference counter of \cl{t[0]} is decremented and \cl{t[0]} has a chance to be freed if nothing else points to it.\\ \hline
\end{tabular}

This requires to build our own C garbage collector \ref{fig:GC.h}.

\begin{figure}
\begin{lstlisting}
struct entry_s {
   void*  pointer;
   int    counter;
   struct entry_s *tl;
};
typedef struct entry_s* entry;

struct hashtable_s {
   int    size;
   entry* table;	
}; 
typedef struct hashtable_s* hashtable;

hashtable ht_create  ( int size );
int       ht_hashfunc( hashtable hashtable, void* pointer );
entry     ht_newentry( void* pointer );

hashtable GC_hashtable;
void      GC_start();
void      GC_quit();
entry     GC_get_entry( void* pointer );
void      GC_add_entry( entry e);
void      GC_new( void* pointer );
void*     GC( void* pointer );
int       GC_count( void* pointer );
void*     GC_malloc( int length, int size );
int       GC_free(void* pointer);
\end{lstlisting}
\caption{Garbage collector C header file: GC.h}
\label{fig:GC.h}
\end{figure}



\subsubsection{How to use it}

The garbage collector mus be used for every manipulation of pointers to memory allocated on the heap. This occurs typically when representing PVS arrays or data structure. These rrays are created in the code.\\

%% Deprecated example...
%\begin{lstlisting}
%int* f() {
%  int* res;
%  res = (int*) GC_alloc( 10 * sizeof(int) );
%  [... init res...]
%  return res; // pointer count = 1
%}
%
%void main() {
%   int* a = f();  // pointer counter of a = 1
%   int** b = (int**) GC_alloc( sizeof( int*) );
%   GC_free( b[0] );  // useless
%   b[0] = (int*) GC( a );  // pointer counter of a = 2
%   printf("f(0) = %s", b[0][0]);
%   GC_free(b); // frees b, pointer count of a = 1
%   GC_free(a); // frees a
%}
%\end{lstlisting}


When \cl{A} points to an array (or \cl{struct}) we want to update destructively, we first check if the pointer counter on \cl{A} is 1. If so, we can update in place because only the local variable \cl{A} points to the array.\\

However, we need to be carefull.
$$ \cl{g(A:Array) : int = f(A, A WITH [(0) := 3] )}$$
should not be translated to
\begin{lstlisting}
g(int* A) {
  A[0] = 3;
  return f(A, A);
}
\end{lstlisting}
for (at least) two reasons:
\begin{itemize}
\item The variable \cl{A} is updated destructively but it is later used as a reference to the previous value of the array.
\item \cl{f} is given twice a pointer to the same data structure. Its reference counter should be incremented.
\end{itemize}

Instead we could flatten the expression \ref{fig:exampleGC}.

\begin{figure}[h!]
\begin{lstlisting}
void main() {
   GC_start();
   
   int* A = GC_malloc(10, sizeof(int) );  // Pointer counter of A = 1
   int i;
   for(i = 0; i < 10; i++)  // Initialisation of A
      A[i] = i;             // Here A = lambda(x):x
   int* B = g( GC(A) );     // We need A further, we make sure that g knows
   int* C = A;              // main still has a pointer to A
   printf("Pointers to C = %d", GC_count(C) ); // equal to 2
   GC_free(B); // Frees B
   GC_free(C); // Only decrement the counter of C
   GC_free(A); // Frees A (and C)
   GC_quit();
}

g(int* A) {
  int* arg1 = GC(A);           // A and arg1 now both point to the array
  int* arg2;
  if (GC(A) == 1)             // This is false
     arg2 = GC( A );
  else {                      // The update must be done non destructively
     arg2 = GC_malloc( 10, sizeof(int) );
     int i;
     for(i =0; i < 10; i++)
         arg2[i] = A[i];
  }  
  arg2[0] = 3;
  GC_free(A);                 // A is never used afterwards, we free it here
                              //(this requires an analysis of the C code)
  int* result = f(arg1, arg2);// A function is responsible for freeing its arguments
                              // (this is why we don't free arg1 and arg2)
  return result;
}
\end{lstlisting}
\caption{Example of the use of the GC}
\label{fig:exampleGC}
\end{figure}


But again, we are lucky here that \cl{A} is the first argument of \cl{f}. If the updated \cl{A} were the first arguments, the update would have been done destructively.
This is why the GC alone is not enoug. We need an analysis of the C code to determine whether a variable is goingto be used later in the code or not. cf \hyperref[Canalysis]{\ref*{Canalysis} Analysis of the C code}.


\subsubsection{Pros and cons}

The use of a garbage collector integrated in the C code seems like a good idea when translating a functionnal language to C. Using a pointer counting GC allows to 

We need an analysis of the C code for two reasons:
\begin{itemize}
\item To \cl{GC\_free} variable as soon as they are not needed anymore. Otherwise copies that could be avoided are performed because an other (useless) pointer still points to the structure we're interested in.
\begin{lstlisting}
  int* B = GC( A );
  update(B, 0, 1); // Can't be done destructively because A also points to
  GC_free(A);     // the same data as B
  f( GC(B) );     // f is given a variable with a reference counter of 2.
  GC_free( B );   // It might not be able to perform some update destructively
\end{lstlisting}
Should be
\begin{lstlisting}
  int* B = A;
  update(B, 0, 1);  // Can be done destructively
  f( B );           // f is given a variable with a reference counter of 1.
\end{lstlisting}
\item 
\end{itemize}

Every update require now tests and calls to hashtable functions. This is a small cost compared to the copying it may allow to avoid but no so small compared to a single in place update that could be decided by a code analysis.\\

Besides, the code gets much bigger since every update or copy requires the code to both destructive and non destructive operation and the if statement to decide which one to use.

Passing argument to function :
\begin{lstlisting}
int* f(int* arg) {
   int* result;
   if ( GC_count(arg) == 1)
      result = GC( arg );
   else {
      result = GC_malloc(10, sizeof(int));
      int i;
      for(i = 0; i < 10; i++)
         result[i] = GC( arg[i] );
   }
   GC_free(arg);
   result[0] = 3;
   return result;
}
\end{lstlisting}

This add quite some code compared to the simple :

\begin{lstlisting}
int* f(int* arg) {
   arg[0] = 3;
   return arg;
}
\end{lstlisting}




\subsection{Using a different data structure}

The Lisp code generated by PVS and used for example by the ground evaluator to compute PVS expressions represents PVS arrays with a more complex data structure than a simple array. It basically consists in an array and a replacement list. Every time an update on \cl{(A, l)} is performed, the result is a pointer to the same array \cl{A} and a replacement list with an extra term: \cl{(A, (0:=0) :: l)}. When the length of the list becomes too big, we create a new array \cl{A'} by applying the replacement terms to a copy of \cl{A} and we return \cl{(A', nil)}.\\

We could represent C data structure with a similar C structure. For example :
\begin{lstlisting}
struct r_list {
   int key;
   int value;
   r_list* tl;
};
struct array_int {
   int *data;
   r_list* replacement_list;
};
\end{lstlisting}

Each structure represent the array \cl{data} with the modifications contained in the linked list \cl{r\_list\_int}.\\

As in the previous solution, we have the following issues:
\begin{itemize}
\item This adds some extra code
\item This adds some extra computation. We need runtime tests for updates, and access to an element not requires reading the whole replacement list.
\item This relies on lot on the GC.
%\item This requires to create as many structures and associated functions as there are range types for the manipulated arrays.
\end{itemize}


\subsection{Flow analysis on the PVS code}

An other optimization would be to perform a analysis on the PVS variables to make sure an udate
Pavol \cite{pavol} suggests three analysis...



\subsection{Analysis of the C code}
\label{Canalysis}

This solution consist in performing an analysis on the C code internal representation before generating the actual output C code.\\

We use flags and two different version of the translated functions to translate update expressions (or dangerous function calls) into a destructive update as often as possible.\\


We define three flags:
\begin{itemize}
\item \bang means that the variable is the only pointer to the structure or array it points to. For instance if we have \cl{f(A:Arr):Arr = A WITH [(0) := 0]} then when \cl{f} is called in
$$ \cl{let A = lambda(x:int):x in let B = f(A) in B(0)} $$
we know that \cl{f} can update \cl{A} in place. We call the following version of \cl{f}.
\begin{lstlisting}
int* f(int* A) {
  A[0] = 0;
  return A;
}
\end{lstlisting}

\item \safe means that an occurrence of a variable is the last occurrence of that variable in the code. We need this flag to avoid updating destructively variables that appears later in the code. In the previous example, if we encounter
$$ \cl{let A = lambda(x:int):x in let B = f(A) in B(0) + A(0) }$$
we know we can't update \cl{A} destructively and we call instead a non-destructive version of \cl{f}:
\begin{lstlisting}
int* f(int* A) {
  int* res = malloc(...);
  for( i ...) res[i] = A[i];
  res[0] = 0;
  return res;
}
\end{lstlisting}

\item \dupl means that this expression may find itself nested in the result of the current function. For instance the identity function, \cl{id(A:Arr):Arr = A}, has its argument flagged \dupl. Therefore when \cl{id} is called we know that the result contains a pointer to its argument.
\begin{lstlisting}
...
int* A = malloc(...);
[ init A somehow ]
int* B = id(A);
\\ From now on B and A point to the same array
\\ For instance, A should probably not be modified in place
...
\end{lstlisting}
\end{itemize}

We want to ensure the following properties:

\begin{figure}
\begin{itemize}
\item Only function declarations and variables with type struct or array can be flagged \bang.
\item Only a single occurrence of a variable may be flagged \safe.
\item Only expressions and arguments can be flagged \dupl.
\item The last and only the last occurrence of a variable is flagged \safe.
\item Arguments of a non destructive function are never flagged \bang.
\item A function is flagged \bang iif its return variable is flagged \bang.
\item A variable may be flagged bang if it is created with a \cl{copy}, \cl{init\_array}, \cl{init\_record} or is the result of a call to a function flagged \bang.\\
It may not be flagged \bang if it is the result of a call to a function not flagged \bang.
\item A call to a destructive function \cl{f\_d( $a_i$, $b_j$, $c_k$ )} (where $a_i$ are flagged \bang and $b_j$ are flagged \dupl and $c_k$ are not flagged) may only occurs if the following conditions on the arguments passed $( A_i, B_j, C_k )$ are met:
\begin{itemize}
\item All $A_i$ are either calls to functions flagged \bang or variables flagged \bang and \safe.
\item All $B_j$ are either calls to functions or variables flagged \safe or not flagged \bang.
\item If the function call is flagged \dupl, then all $B_j$ are also flagged \dupl.
\end{itemize}
\item If a variable is once flagged \dupl, then if it is an argument, this argument is also flagged \dupl.
\end{itemize}
\caption{Propeties of the flags}
\label{fig:properties}
\end{figure}



\subsubsection{Algorithm}

Each PVS function is translated into two different C functions:
\begin{itemize}
\item A "cautious" non destructive version whose arguments are never \bang and therefore never modifies the arguments in place, always making copies when necessary. This doesn't mean this function can't make destructive update. For instance locally created arrays (using \cl{init\_array}) will be flagged \bang and might be destructively updated, should the conditions be met.
\item A destructive version which requires as many arguments as possible to be \bang and tries to do destructive updates as often as possible. This function only requires \bang arguments if it uses it destructively though.
\end{itemize}


\begin{figure}
\begin{lstlisting}
f(int* A, int* B) {         // A and B are both flagged duplicated
   if (A[0] == 0) {
      return B;
   } else {
      int* arg1 = copy(B);  // arg1 is flagged mutable and duplicated
      arg1[0] = arg1[0] - 1;
      f(arg1, A); // Both these occurrences of arg1 and A are flagged safe
   }
}

f_d(int* A, int* B) {  // A and B are both flagged mutable and duplicated
   if (A[0] == 0) {
      return B;
   } else {
      int* arg1 = B;    // No need to copy since B is mutable
                        // and never occurs afterwards
      arg1[0] = arg1[0] - 1;
      f_d(arg1, A);     // we can call f_d since the requirements are met:
   }                    //    both arg1 and A are flagged mutable
}
\end{lstlisting}
\caption{Example of the two different versions of a C function generated (stripped from GC instructions)}
\end{figure}




\begin{figure}
\begin{itemize}
\item Create the two versions of a function
\item Flag all arguments \bang in destructive version
\item Perform several passes and move flags to make sure the properties Figure~\ref{fir:properties} are verified.
\item Modify the code if the flags allow it according to the rules defined in the Annex~\ref{Rules}.
\item Redo the two previous steps until stabilization.
\end{itemize}
\caption{Algorithm}
\end{figure}





In destructive versions of all functions :
Flag all array arguments to "mutable".
Then for each of these arguments :
  - If it never occurs destructively, then remove flag
          (function just read the arg)
  - If it occurs destructively, it can never occur at all AFTER.
  -> Need to define the order of evaluation of expression
      (easy rules on simple expressions)
  -> Need to be able to detect occurences of a name-expr
  -> Otherwise, unflag the arg

A variable $V$ of type array is created in these cases:
\begin{itemize}
\item \cl{$V$ = $\lambda$x.e(x)} : $V$ has bang type
\item \cl{update($V$, $T$, key, value)} : $V$ has bang type because this is basically a copy and a destructive update.
\item \cl{f($V$,...) = ...} : type of $V$ depends on \cl{f}.
\end{itemize}
In these case, it has always bang type.\\
Or it can be set to an other referenced object.
\begin{itemize}
\item \cl{$V$ = $T$} $\rightarrow$ $V$ (should have bang type iff $T$ has !type too and never occurs afterwards). Happens in 
\item \cl{$V$ = $T$[i]} $\rightarrow$ depends on the target type of $T$.
\item \cl{$V$ = $T$.field} $\rightarrow$ depends on the type of the field.
\end{itemize}
At first all updates are non destructive.

First pass : All array variables (actuals and local variables) found in the code are flagged. Local variables are flagged according to the previous rules and actuals are flagged \textbf{mutable} in destructive version and \textbf{not mutable} in non-destructive versions. In functions returning an array (or record type), the variable result is also flagged.\\

Other passes :
Reading the code backwards, for every occurrence $T$ of a variable flagged \textbf{mutable}:
\begin{itemize}
\item If it is found in a \cl{$V$ = $T$} instruction, then we give the bang type to $V$ and remove bang type from $T$ so that previous occurrences of $T$ won't assume the uniqueness of the reference. This adds a new variable to the set of bang variables, hence the need to make several passes.
\item If it is used in a \cl{$V$ = copy($T$)} instruction, then we replace it with a \cl{$V$ = $T$} instruction and do as previous.
\item If it is found in an \cl{update($V$, $T$, i, e}, then turn that into \cl{$V$ = $T$; destr\_update($V$, i, e) }.
\item If it is a function call 
\item If we reach the declaration of a variable that is marked \textbf{mutable}, this means this variable is never read. In that case, we actually don't need it (unflag it I guess...).
\end{itemize}

At the end, when we have reached the transitive closure of this definition, if we reach the beginning of the function and some arguments are still bang, this means their bangness is never used, put the flag on that argument to \cl{non mutable} and remove the instructions freeing that variable (reminder : mutable arguments of a functions are freed inside the function or are used in a mutable way and appear somewhere in the result (trapped in closures) or are freed in other function calls.



\subsubsection{Algorithm}




All variables have three flags: $M$ (mutable), $D$ (duplicated) and $T$ (treated).

Init:\\
All arguments of a destructive function are flagged \cl{($M$ = true, $D$ = false, $T$ = true)}.\\
All arguments of a non destructive function are flagged \cl{($M$ = false, $D$ = false, $T$ = true)}.\\
All other variables are flagged \cl{($M$ = false, $D$ = false, $T$ = false)}.\\

Rules:\\
When $M$ is changed, $T$ is set to \cl{true}.\\
When $T$ is \cl{true}, the flag $M$ can only be set to \cl{false}.
This prevent infinite change of the flag $M$.\\
The flag $D$ can only be set to \cl{true}.\\



Initialization:\\


We initialize a set $M$ of mutable variables to all array arguments of a function $f$.
We also initialize a set $F$ of variables to free to $M$ since $f$ has the resposnability to free all variables flagged as mutable arguments.\\

We read the code backwards.\\
$T_i$ refer to variables that are in the set $M$.\\
$S_i$ refer to variables that are not in the set $M$.

\begin{tabular}{|p{60mm}|p{90mm}|}
\hline
\cl{$S$ = $T$} & $M \leftarrow M \cup \{ S \} - \{T\}$ \newline $F \leftarrow F \cup \{ S \} - \{T\}$  \\ \hline
\cl{$S$ = update($S_2$, key, value}) & $M \leftarrow M \cup \{ S \}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline
\cl{$S$ = update($T$, key, value}) & $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline

\cl{$S$ = g($T_i$, $S_i$}) & If the arguments of \cl{g} don't allow \cl{g} to be called destructively: \newline $M \leftarrow M - \{T_i \}$ \newline $M \leftarrow M \cup \{ S \}$ if return type of \cl{g} is \mut \newline $F \leftarrow F \cup \{ S\}$ \\ \hline

\cl{$S$ = g($T_i$, $S_i$}) & Otherwise: \newline \cl{$\rightarrow S$ = g\_d($T_i$, $S_i$} \newline $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline

\cl{$S$ = $S_2$[i]} & $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline


\end{tabular}




All arguments of the function are flagged \mut 




What is a destructive occurence :
$$ E :=  \cl{f(  t with [ e1 := e2 ] , t(0) )} $$
order of eval :
e1 and e2  (t can occur non destr)
t          ( expression of an update : destr)
t(0)       ( occurence of t (even non destr))

\cl{f(x:Arr):int = g( h(t), t)}  is destructively translated to \\
\begin{lstlisting}[numbers=left,caption=Example]
int f_d(int* t) {   // t has type ! since this is destructive f
  int* arg1 = h(t); // h can't be called destructively because
                    // even though t is !, it appears later (line 4)
  int* arg2 = t;    // t is ! and never appears later => arg2 is !
  return g( arg1, arg2); // arg2 is ! but g can only be called
}                        // destructively if arg1 is
\end{lstlisting}

if g has type \cl{[Array! -> ?]} then t can't be destructive\\

if g has type \cl{[Array -> ?]} then t can be destructive

First algorithm:


Need multiple passes as the flags disappear




\begin{figure}
\begin{tabular}{|p{50mm}|p{62mm}|p{45mm}|}
\hline
\cl{update(A, key, value)} & \cl{A[key] = value;} & \cl{A} must be \mut \\ \hline
\cl{set(A, $expr$)} & \cl{A = $expr$;} \\ \hline
\cl{declare(A, $expr(i)$)} & \begin{lstlisting}
A = malloc(l * sizeof(T) );
int i;
for(i = 0; i < l; i++)
   A[i] = i + 1;
\end{lstlisting} & \\ \hline
\cl{copy(A, B)} & \begin{lstlisting}
A = malloc(l * sizeof(T) );
int i;
for(i = 0; i < l; i++)
   A[i] = B[i];
\end{lstlisting} & \\ \hline
\cl{init(A)} & \cl{int* A;} & \\ \hline
\cl{free(A)} & \cl{free(A);} & \\ \hline
\cl{base(str, (A, B, ...))} & \cl{int aux = A[0] + B[1];} & \cl{A} and \cl{B} are only read. \\ \hline
\cl{return} & \cl{return result;} & \\ \hline
\end{tabular}
\caption{C instructions}
\end{figure}



\begin{figure}
\begin{tabular}{|p{50mm}|p{50mm}|p{50mm}|}
\hline
\cl{value($cste$)} & \cl{42} & \\ \hline
\cl{variable($type$, $name$)} & \cl{name} & \\ \hline
\cl{call(f, $exprs$)} & \cl{f( $expr_1$, $...$, $expr_n$ )} & \\ \hline
\end{tabular}
\caption{C expressions}
\end{figure}




\subsection{Combination of solutions}

We use the C code analysis to write some updates as destructive. However a few updates remain non destructive. For example:\\

If a function is called but requires its two argument to be \mut  and only the first is \mut. Then the non-destructive version is called and the first argument gets copied even though it was \mut.\\

If we perform an update on \cl{$T$[i]}, our analysis doesn't tell if \cl{$T$[i]} is \mut or \nmut.\\

To prevent that, we also perform a GC check. An update is actually a test wether an object is \mut or not and the appropriate update.



\newpage
\section{Conclusion}


\subsection{Difficulties and successes}


\subsubsection{Integrating the GMP library}
In PVS, the \texttt{integer} represent the whole set $\Z$ of all relative numbers (and \texttt{rational} also describe $\Q$).
To implement that in C, we need more than the finite types \cl{int}, \cl{long}, ...

We use the GMP library which introduces the types \mpzt and \mpqt. These types are pointers (actually arrays) to structures and they had to be used with caution (allocation, freeing, ...).

For example, a function returning a \mpzt should actually take a first \mpzt argument and set it to the return value. Its return type being \cl{void}.

\begin{figure}[h!]
\cl{norm(x:int, y:int):int = x*x + y*y}
\begin{lstlisting}
void (mpz_t result, mpz_t x, mpz_t y) {
  mpz_t aux1;
  mpz_init(aux1);
  mpz_mul(aux1, x, x);
  mpz_t aux2;
  mpz_init(aux2);
  mpz_mul(aux2, y, y);
  mpz_add(result, aux1, aux2);
  mpz_clear aux1;
  mpz_clear aux2;
}
\end{lstlisting}
\caption{Example of the GMP library use}
\end{figure}


\subsubsection{Working with new languages and tools}
I had to learn three languages PVS, C, Common Lisp.



\subsection{What's left to be done ?}

Use a C structure to represent a closure
\begin{lstlisting}
struct r_list_int {
   int (*body)(void* env, void* args);
   void* env;
   void* args;
};
\end{lstlisting}



\subsection{My stay at SRI}

Besides the conception and implementation of the PVS to C compiler, my stay at SRI International was rich in ??? events.

The first days of my stay were the occasion to discover PVS anc Coq as I started working on a translator Coq to PVS. With Robin, we also wrote as an exercise a basic linear algebra library.

I discovered Lisp the hard way while learning how the back end of PVS worked. I've wrote a Lisp parser to help me see clear in the huge code (classes definitions, inheritances and organization, function dependances, ...)

I also have had the chance to attend to the many interesting seminars SRI hosted every week.
The SRI also organized a Summer School to which we were allowed to attend and which was very interesting.

Shankar never hesitated to include us in many project

I've been included in the HACMS project which was very interesting.
With other:
Correcting translator PVS to SMT-LIB




\subsubsection*{Draft}
Discovering PVS :
Translating Coq proofs to PVS
PVS library for basic linear algebra

Robin project, HACMS \\
Contest week-end 14-15 June \\
Summer School \\
Parsing Lisp code -> generate HTML architecture file\\
Correcting translator PVS to SMT-LIB
\cite{pavol}





\bibliographystyle{plain}
\bibliography{allbib}





\appendix

\newpage
\section{PVS Syntax and CLOS representation}

\begin{figure}[h]
\input{includes/PVS-expr}
\caption{Syntax of the PVS subset of the translator}
\label{fig:PVSsyntax}
\end{figure}

\begin{figure}[h!]
\input{includes/PVS-CLOS}
\caption{(Partial) CLOS representation of PVS syntax}
\label{fig:PVS-CLOS}
\end{figure}

\newpage
\section{PVS type system and CLOS representation}

\begin{figure}[h!]
\input{includes/PVS-type}
\caption{Fragment of the PVS type system}
\label{fig:PVS-types}
\end{figure}


\begin{figure}[h!]
\input{includes/PVS-CLOS-type}
\caption{(Partial) CLOS representation of PVS types}
\label{fig:PVS-CLOS-types}
\end{figure}


\newpage
\section{Target language and CLOS representation}


\begin{figure}[h!]
\input{includes/C-expr}
\caption{Syntax of the representation of the target language (subset of the C language)}
\label{fig:Csyntax}
\end{figure}





\newpage
\section{Rules}
\label{Rules}


\begin{figure}[h!]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
             & \cl{A} \safe & \cl{A} not \safe \\ \hline
\cl{A} \mut  & Replace every occurence of the variable \cl{B} by the variable \cl{A} & \begin{lstlisting}
B = GC_malloc(...);
for(i ...) {
  B[i] = A[i];
}
\end{lstlisting} \\ \hline
\cl{A} \nmut & \begin{lstlisting}
if (GC_count(A) == 1) {
  B = A;
} else {
  B = GC_malloc(...);
  for(i ...) {
    B[i] = A[i];
  }
}
\end{lstlisting} & \begin{lstlisting}
B = GC_malloc(...);
for(i ...) {
  B[i] = A[i];
}
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Rules for \cl{copy(B, A)}}
\end{figure}



\begin{figure}[h!]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
             & \cl{A} \safe & \cl{A} not \safe \\ \hline
\cl{A} \mut  & Replace every occurence of the variable \cl{B} by the variable \cl{A} & \begin{lstlisting}
B = GC_malloc(...);
for(i ...) {
  B[i] = A[i]
}
\end{lstlisting} \\ \hline
\cl{A} \nmut & Replace every occurence of the variable \cl{B} by the variable \cl{A} & \begin{lstlisting}
B = GC( A );
\end{lstlisting}
If \cl{B} is flagged \dupl then \cl{A} must be too.
\\ \hline
\end{tabular}
\caption{Rules for \cl{set(B, A)}}
\end{figure}



\begin{figure}[h!]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
             & \cl{A} \safe & \cl{A} not \safe \\ \hline
\cl{A} \bang  &
\begin{lstlisting}
f_d(A)
\end{lstlisting} & \begin{lstlisting}
f(A)
\end{lstlisting} \\ \hline
\cl{A} not \bang & \begin{lstlisting}
f(A)
\end{lstlisting} & \begin{lstlisting}
f(A)
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Rules for \cl{f(A)} with \cl{A} flagged \bang in the destructive version}
\end{figure}


\begin{figure}[h!]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
             & \cl{A} \safe & \cl{A} not \safe \\ \hline
\cl{A} \bang  &
\begin{lstlisting}
f(A)
\end{lstlisting} & \begin{lstlisting}
copy(B, A)
f(B)
\end{lstlisting} \\ \hline
\cl{A} not \bang & \begin{lstlisting}
f(A)
\end{lstlisting} & \begin{lstlisting}
f(A)
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Rules for \cl{f(A)} with \cl{A} flagged \dupl}
\end{figure}






\newpage
\section{Examples}


\begin{figure}[h!]
\begin{tabular}{|p{5.2cm}|p{5.8cm}|p{6cm}|}
\hline
\begin{center}
PVS code
\end{center} &
\begin{center}
Auxiliary language code
\end{center} &
\begin{center}
C code generated
\end{center} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr = A
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int*} \newline
\cl{set(result, A)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  return A;
}
\end{lstlisting} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr =
  let B = A in B
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int*} \newline
\cl{set(B, A)} \newline
\cl{set(result, B)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  return A;
}
\end{lstlisting} \\ \hline

\begin{lstlisting}
f(A:Arr):Cint =
 let B = A in
  A(0) + B(0)
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int} \newline
\cl{set(B, A)} \newline
\cl{set(result, +( A(0), B(0) ) )} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  int* B = (int*) GC( A );
  int result = A[0] + B[0];
  GC_free(B);
  GC_free(A);
  return result;
}
\end{lstlisting} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr =
  let B = A in
    A WITH [(0) := B(0) ]
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int} \newline
\cl{set(B, A)} \newline
\cl{set(L, 0)} \newline
\cl{set(R, B(0) )} \newline
\cl{update(result, A, L, R)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f_d(int* A) {
  int* B = GC_malloc(...);
  for(i ...)
     B[i] = A[i];
  int L = 0;
  int R = B[0];
  int* result = GC( A );
  result[L] = R;
  GC_free(B);
  GC_free(A);
  return result;
}
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Examples of setting variables}
\end{figure}


\begin{figure}[h!]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
\begin{center}
PVS code
\end{center} &
\begin{center}
Auxiliary language code
\end{center} &
\begin{center}
C code generated
\end{center} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr =
  A WITH [(0) := 0]
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int*} \newline
\cl{set(L, 0)} \newline
\cl{set(R, 0)} \newline
\cl{copy(result, A)} \newline
\cl{update(result, L, R)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  int L = 0, R = 0;
  int* result;
  if( GC_count(A) == 1 ) {
    result = GC( A );
  } else {
    result = GC_alloc(...);
    for(i ...)
      result[i] = A[i];
  }
  result[L] = R;
  GC_free( A );
  return result;
}

int* f_d(int* A) {
  int L = 0, R = 0;
  A[L] = R;
  return A;
}
\end{lstlisting} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr =
 let B = A WITH[(0):=0]
 in A WITH[(0) := B(0)]
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int*} \newline
\cl{set(L1, 0)} \newline
\cl{set(R1, 0)} \newline
\cl{copy(B, A)} \newline
\cl{update(B, L1, R1)} \newline
\cl{set(L2, 0)} \newline
\cl{set(R2, B(0))} \newline
\cl{copy(result, A)} \newline
\cl{update(result, L1, R1)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  int R1 = 0, L1 = 0;
  B = GC_alloc(...);
  for(i ...)
    B[i] = A[i];
  B[L1] = R1;
  int R2 = 0, L2 = B[0];
  result = GC_alloc(...);
  for(i ...)
    result[i] = A[i];
  result[L2] = R2;
  GC_free(A);
  GC_free(B);
  return result;
}

int* f_d(int* A) {
  int R1 = 0, L1 = 0;
  B = GC_alloc(...);
  for(i ...)
    B[i] = A[i];
  B[L1] = R1;
  int R2 = 0, L2 = B[0];
  A[L2] = R2;
  GC_free(B);
  return A;
}
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Examples of copying variables}
\end{figure}

\end{document}
