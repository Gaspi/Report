\documentclass[12pt,a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
% \usepackage[francais]{babel}

\usepackage[left=1.5cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage[colorlinks]{hyperref}
\usepackage{graphicx}

% --- CSL part
\usepackage{natbib}
\input{includes/pvstex}
\usepackage{includes/makebnf}


\usepackage[space]{grffile} % Celui-là je sais plus à quoi il sert...

% --- Partie code
\usepackage{listings}
\lstset{language=C} % Changer eventuellement le nom du langage
\newcommand{\codeline}[1]{\texttt{#1}}

% --- Parti math. (app.)
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{remark}[theorem]{Remark}

% Mathematic abbreviations

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Esp}{\mathbb{E}}
%\newcommand{\E}{\mathbb{E}} % Si tu l'utilise beaucoup
\newcommand{\Prob}{\mathbb{P}}
%\newcommand{\P}{\mathbb{P}} % Si tu l'utilise beaucoup



\title{
\vspace{-3cm}
\normalsize
\begin{tabular}{p{15cm}}
ÉCOLE POLYTECHNIQUE \\
PROMOTION X2011 \\
Férey Gaspard
\end{tabular}
\vspace{3cm}
\begin{center}
\includegraphics[height=3cm]{pictures/logo.png}
\end{center}
\vspace{1cm}
\large
\begin{center}
RAPPORT DE STAGE D'OPTION SCIENTIFIQUE\\
\vspace{1cm}
{\Huge Titre}\\
\vspace{1cm}
NON CONFIDENTIEL
\end{center}
\vspace{3cm}
\normalsize
\begin{tabular}{p{6cm} p{10cm}}
Option :                  & INFORMATIQUE \\
Champ de l'option :       & Math-Informatique \\
Directeur de l'option :   & Olivier Bournez \\
Directeur de stage :      & Olivier Bournez \\
Dates du stage :          & 7 avril - 22 aout 2014\\
Nom et adresse de l'organisme :  & SRI International \\
                          & Computer Science Laboratory (CSL) \\
                          & 333 Ravenswood Avenue \\
                          & Menlo Park, CA 94025-3493 \\
                          & United States
\end{tabular}
}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}

\section{PVS}


\section{Translating PVS to C}


\section{Parsing and typechecking PVS}
These two task we leave to PVS native parser and typechecker.

The parser generates objects representing the expressions of the theory.

We only convert a subset of PVS.
This subset is defined by a subset of expression objects we can translate.
The objective is, of course, to be able to translate the maximum of (if not all) PVS expression objects.



\section{PVS Syntax}
We describe here the syntax of PVS and the objects system used to represent them in Lisp. Some slots of the classes are voluntarily omitted. For a full description of PVS parser representation, refer to \cite{PVS:api}.

\input{includes/bnf-expr-aux}




\section{Types}
A PVS theory can be typechecked using the emacs interface \codeline{M-x typecheck} or with Lisp function \codeline{(tc name-theory)}. This first runs the PVS parser on the code and generates CLOS objects to represent it. Then, the PVS typechecker is run on this internal representation of the theory and tries to give a type to all expressions generating TCC when needed.\\

Here we describe how PVS types are represented in Lisp. The syntax of PVS we allow

\input{includes/bnf-type-expr}

\begin{class}{type-expr}{abstract}{\classhln{syntax}}
{}
\end{class}
\begin{class}{type-name}{}{\classhln{type-expr} \classhln{name}}
{\slotidx{adt} & }
\end{class}
\begin{class}{subtype}{}{\classhln{type-expr}}
{\slotidx{supertype} & \\
 \slotidx{predicate} & }
\end{class}
\begin{class}{funtype}{}{\classhln{type-expr}}
{\slotidx{domain} & \\
 \slotidx{range} & }
\end{class}
\begin{class}{tupletype}{}{\classhln{type-expr}}
{\slotidx{types} & }
\end{class}
\begin{class}{recordtype}{}{\classhln{type-expr}}
{\slotidx{fields} & }
\end{class}


\section{Translating types}
PVS types:\\
boolean, number, number\_field, real, 
rational, integer, $A \rightarrow B$, restricted types
$\text{below}(10) := \{ x:\text{int} | 0 \leq x < 10 \} $)  \\
enum
datatype



Auxiliary type system :
C-type with a flag : mutable (meaning that the expression it describes only has one pointer pointing to it.

\begin{lstlisting}
int a = 2;     a : int[mutable]
int* a = malloc( 10 * sizeof(int*) );  
\end{lstlisting}

destructive addition:

\begin{lstlisting}
d_add(*mpz_t res, mpz_t[mutable] a, long b) {
  mpz_add(a, a, b);
  (*res) = a;
}
\end{lstlisting}

Rq : \codeline{d\_add} is given a mutable \codeline{mpz\_t}, meaning that it can modify it and is responsible for freeing it.
It is also responsible for allocating memory for the result.
Here it uses the memory to assign res.



Use an auxiliary language :

\begin{lstlisting}
( expr, C-type[mutable] )
\end{lstlisting}

Conversions and copies create mutables types (at a cost) :
\codeline{a[mutable]\_from\_b}









C types:\\
[unsigned] char, int, long, double
boolean
arrays
strings
enum
struct
and others: short int, float, union, size\_t, ...










We can only translate a subset of all PVS types.
What's missing ?

\subsection{Translating PVS syntax}


We can only translate a subset of PVS syntax.
What's missing ?



\subsection{Difficulties}
if-expr


\subsubsection{ Update expressions }
Update expressions are represented by PVS as \texttt{update-expr} objects.

$$ E := \texttt{ t with [ e1 := e2 ] } $$


Problem :
\codeline{t} is an expression typed as a function. Therefore it might be represented in C as an array (if domain type is \codeline{below($n$)}.
We want to know if we can update \codeline{t} in place to obtain a C object representing \codeline{E} or if we have to make a copy of \codeline{t}.

Three solutions :

- Pointer counting :

We keep track of the number of pointer pointing to an array or a struct.

This requires to build our own C struct (heavy)
\begin{lstlisting}
struct array_int {
   int pointer_count = 1;
   int *data;
};
\end{lstlisting}

When we update the struct, if the pointer is 0, we update in place.\\

Besides every update require now to read the structure and make a test (small compared to a copy but no so small compared to a single in place update)\\

Besides, the creation / destruction gets more complicated\\

Passing argument to function :
\begin{lstlisting}
array_int f(array_int arg) {
   arg.pointer_count++;  \\ Since now f also have a pointer to the struct
   if (arg.pointer_count == 1) {
      arg.data[0] = 0;
      return arg;
   } else {
      array_int res;
      res.data = malloc( 10 * sizeof(int*) );
      copy(res, arg);  // Very long...
      res.pointer_count --; // This function is about to lose its pointer to res
      return res;
   }
}

void main() {
   array_int t;
   init(t);  // somehow...
   
   t.pointer_counter --;  // We assure we won't use the pointer "t" to the array anymore
   array_int r = f(t);
   t = null; // This way we garantee the variable "t" won't be used later in the code
   
   [...]   
}
\end{lstlisting}

This add quite some code compared to the simple :

\begin{lstlisting}
array_int f(array_int arg) {
   arg[0] = 0;
   return arg;
}

void main() {
   array_int t;
   init(t);  // somehow...
   array_int r = f(t);
   
   [...]   
}
\end{lstlisting}



- Using a different data structure

PVS uses arrays in a very particular way, we might then represent them with an other structure than just only a C array.
For example :

\begin{lstlisting}
struct r_list_int {
   int k;
   int v;
   r_list_int tl;
};

struct array_int {
   int *data;
   r_list_int replacement_list;
};
\end{lstlisting}

Each structure represent the array \codeline{data} with the modifications contained in the linked list \codeline{r\_list\_int}

Problems : Just as the previous solution :
- add some extra code
- add some extra computation (runtime tests)
- require to create as many structures and associated functions as there are range type fo the manipulated arrays


- Third solution :

Trying to avoid copying arrays by analyzing the code.
2 different functions (destructive and non destructive)


Algorithm :

Always have a "non destructive" version of any function. A "cautious" version that never modify the arguments in place and always make copies when necessary (when a "mutable" version of an array is necessary (for instance updates)).

In destructive versions of all functions :
Flag all array arguments to "mutable".
Then for each of these arguments :
  - If it never occurs destructively, then remove flag
          (function just observe the arg)
  - If it occurs destructively, it can never occur at all AFTER.
  -> Need to define the order of evaluation of expression
      (easy rules on simple expressions)
  -> Need to be able to detect occurences of a name-expr
  -> Otherwise, unflag the arg

What is a destructive occurence :
$$ E :=  \codeline{f(  t with [ e1 := e2 ] , t(0) )} $$
order of eval :
e1 and e2  (t can occur non destr)
t          ( expression of an update : destr)
t(0)       ( occurence of t (even non destr))

f( g(t), t)
if g has type [Array! -> ?] then t can't be destructive
if g has type [Array  -> ?] then t can be destructive

need multiple passes as the flags disappear









\section{Other works at SRI}

Discovering PVS :
Translating Coq proofs to PVS
PVS library for basic linear algebra

Robin project, HACMS \\
Contest week-end 14-15 June \\
Summer School \\
Parsing Lisp code -> generate HTML architecture file\\
Correcting translator PVS to SMT-LIB




\bibliographystyle{plain}
\bibliography{report}


\end{document}
