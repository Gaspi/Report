\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage[left=1.5cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{graphicx}

\usepackage{includes/bussproofs}

% --- CSL part
% \usepackage{natbib}
\input{includes/pvstex}
\usepackage{includes/makebnf}

\usepackage[space]{grffile}
\usepackage{pdfpages}

\usepackage[%
backend=biber,
style=alphabetic,
backref=true,
backrefstyle=all+,
hyperref=true,
]{biblatex}

\bibliography{allbib}




% --- Partie code
\usepackage{listings}
\lstset{language=C,
        showstringspaces=false,
        basicstyle=\footnotesize\ttfamily,
        captionpos=b,
        stepnumber=1,
        keywordstyle=\bfseries\color{green!40!black},
        commentstyle=\itshape\color{purple!40!black},
        identifierstyle=\color{blue},
        stringstyle=\color{red}}

\newcommand{\cl}[1]{\texttt{#1}}

% --- Parti math. (app.)
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{remark}[theorem]{Remark}

% Mathematic abbreviations

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Esp}{\mathbb{E}}
%\newcommand{\E}{\mathbb{E}} % Si tu l'utilise beaucoup
\newcommand{\Prob}{\mathbb{P}}
%\newcommand{\P}{\mathbb{P}} % Si tu l'utilise beaucoup

\newcommand{\mpzt}{ \texttt{ mpz\_t } }
\newcommand{\mpqt}{ \texttt{ mpq\_t } }

\newcommand{\mut}{  \textbf{ mutable } }
\newcommand{\nmut}{ \textbf{ non-mutable } }
\newcommand{\bang}{ \textbf{ mutable } }
\newcommand{\safe}{ \textbf{ safe } }
\newcommand{\dupl}{ \textbf{ duplicated } }

% evaluation context hole
\newcommand{\econt}[1]{[#1]}
% update context hole
\newcommand{\ucont}[1]{\{#1\}}


\begin{document}

\includepdf[pages={1}]{includes/frontpage/frontpage.pdf}

\newpage
\
\vspace{2in}
\begin{abstract}
PVS (standing for Prototype Verification System), is an Open Source project developped by CSL at SRI International and aiming to be both a semi-automated theorem prover and a programming language. 
\end{abstract}

\vspace{1in}
\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
I would like to thank my supervisor, Natarajan Shankar, for his help, explanations and suggestions as well as for the many enlightening discussions we had during this internship. I also thank Sam Owre for his explanations of the PVS API and Common Lisp in general, Robin Larrieu, from Polytechnique who shared an office and a lot of good ideas with me. I thank all of my teachers from  LIX who made this internship possible, with a special mention to St√©phane Graham-Lengrand and Benjamin Doerr who recommended me.
Finally, I thank all the people at the CSL, for their welcome, the interesting discussions I had with them, and for creating an exciting and inspiring environment for work. 
A special thank Lori Truitt for all the help she provided with administrative paperwork.
\end{abstract}


\newpage
\tableofcontents
\newpage

\section{Introduction}


\subsection{PVS Overview}

PVS  (Prototype Verification System) is an environment for specification and proving. The main purpose of PVS is to provide 
formal support for conceptualization and debugging in the early stages of the lifecycle of the design
of hardware or software systems. In these stages, both the requirements and designs are expressed in abstract
terms that are not necessarily executable. The best way to analyze such an abstract specification is by 
attempting proofs of desirable consequences of the specification. Subtle errors revealed by trying to prove
the properties are costly to detect and correct at later stages of the design lifecycle.
\\The specification language of PVS is built on higher-order logic (functions can be treated like
primitive types: functions can take functions as arguments and return them as values, quantification
can be applied to function variables. Specifications can be constructed using definitions and axioms







\subsection{Why translate PVS ?}

\subsubsection*{The HACMS Project}

\subsubsection*{Other translators}

- Common Lisp (native)
- ground evaluator
- Yices
- Clean




\section{Translating PVS}

\subsection{Translation's architecture}

The translation from PVS \cite{PVS:manuals} to C follow five main steps:
\begin{itemize}
\item Typechecking: The PVS typechecker \cite{PVS:userguide} perform a type analysis on the PVS code to associate a PVS type to each expression. This might generates some proof obligations (TCC). The user of the translator has to make sure that the PVS code can be correctly typechecked and that all TCC can be proven.

\item Lexical and syntactic analysis: The PVS parser transforms PVS \cite{PVS:language} code into a CLOS internal representation. \\

In Figure~\ref{fig:PVSsyntax}, we describe the syntax of the subset of PVS we are currently able to translate to C.
In Figure~\ref{fig:PVS-CLOS}, we describe the Common Lisp Object System architecture used by PVS to represent them in Common Lisp. Some classes and some slots in the classes are voluntarily omitted. For a full description of PVS parser representation, refer to \cite{PVS:api}.

\item Translation: The translator flattens PVS expressions to generates an intermediate language which heavily relies on the use of intermediate variables to allow a simpler static analysis. The syntax of this language is described Figure~\ref{fig:aux-syntax}.

\item Static analysis: The intermediate language is analyzed and stripped from some of its unnecessary copies and non destructive updates using flow analysis and an enriched type system. This analysis inspired from Shankar \cite{shankar02} and Pavol Cerny's \cite{pavol} previous analysis of PVS is described with more detail in Section~\ref{staticanal}.

Typically, an expression $e$ is translated into a tuple of four elements $(t,e,i,d)$, where $t$ represents a C type used to describe the expression, $e$ is a simple expression, $i$ is a list of instructions to be executed prior to using $e$, the initialization of the expression. Finally $d$ is a list of instructions to be executed when $n$ isn't needed anymore, the destruction of $e$.

\item Optimizations: Several simple analysis are performed, for instance to determine where to declare and free variables as well as the most adapted C types to use. The code generated from that step can be described by the syntax in Figure~\ref{fig:Csyntax}.

\item Code generation: C code is generated (.c and .h files) and can be compiled using gcc and executed when linked with the garbage collector and the GMP library. The C syntax is described in \cite{huss2004c} and the GMP library reference can be found at \href{https://gmplib.org/manual/}{https://gmplib.org/manual/}.
\end{itemize}



Describe here the Lisp functions and data structures

Skeleton

Expected input

Output objects

Assertions that we (try to) maintain




We first define a function $T$ to translate an expression $e$.
$$ T(e) = ( \ T^t(e) \ , \ T^n(e) \ , \ T^i(e) \ , \ T^d(e) \ ) $$

\begin{figure}[!ht]
\begin{eqnarray*}
T(\cl{2}) &= (& \cl{int}, "2", [], []) \\
T(\cl{4294967296}) &= (& \cl{mpz\_t}, \ ? \ , \\
&& [ \cl{mpz\_init(?);} \ | \\
&& \ \cl{mpz\_set\_str(?, "4294967296");} ],\\
&& [ \cl{mpz\_clear(?);} ]) \\
T(\cl{lambda(x:below(10)):x}) &= (& \cl{int*}, \ ? \ , \\
&& [ \cl{? = malloc(10 * sizeof(int));} \ | \\
&& \ \cl{int i;} | \\
&& \ \cl{for(i = 0; i < 10; i++) }\\
&& \ \ \ \cl{?[i] = i;}  ]\\
&& [ \cl{free(?);} ])
\end{eqnarray*}
\caption{Translation examples: number expressions}
\end{figure}

It may occur that $T^n(e) = ?$. In that case, the symbol $?$ appearing in $T^i(e)$ and $T^d(e)$ needs to be replaced by a proper variable name.\\

We then define two other operators:
\begin{itemize}
\item $R$ wich take an expression and a type and may add an extra conversion in the instructions to make sure its result has the expected type. Also the result of this function has a proper name.
\item $S$ which take an expression, a type and a name. It makes sure that the given variable (type + name) is set to a value representing the expression.
\end{itemize}




\subsection{A few translation rules}

Translation rules :




\begin{lstlisting}
number-expr "2"
(C-int, "2", [], [])

number-expr "12315468453213"
(C-mpz, nil,
        [mpz_t ~a; | mpz_t_init("12315468453213"); ],
        [mpz_clear ~a;])

application "f(e1, e2)"
(C-mpz, nil,
       [ instr(e1) | instr(e2)
                   | mpz(~a); | f(~a, e1, e2) ]
       [mpz_clear(~a);]
\end{lstlisting}



\subsection{PVS type system}

\subsubsection{PVS Types}
A PVS theory can be typechecked using the emacs interface \cl{M-x typecheck} or calling the Lisp function \cl{(tc name-theory)}. This first runs the PVS parser on the code and generates CLOS objects to represent it. Then, the PVS typechecker is run on this internal representation of the theory and tries to give a type to all expressions generating TCC when needed.\\

Here we describe how PVS types are represented in 
Lisp.

Figure~\ref{fig:PVS-types} \\
Figure~\ref{fig:PVS-CLOS-types}


\subsubsection{Translating types}
PVS types:\\
boolean, number, number\_field, real, 
rational, integer, $A \rightarrow B$, restricted types
$\text{below}(10) := \{ x:\text{int} | 0 \leq x < 10 \} $)  \\
enum
datatype


This requires a type analysis to decide on the type of a PVS expression. For example the PVS \cl{int} type can be represented by the \cl{int}, \cl{unsigned long} or \cl{mpz\_t} C types. In that case, we study the range of the expression to decide which types are allowed to represent it. Then we take the context in which the expression appears to decide. For instance in
\begin{lstlisting}
incr(x:below(10)):int = x+1
\end{lstlisting}
the \cl{x} expression, result of the function \cl{incr} can always be represented by an \cl{int} or \cl{unsigned long} in C but we choose here to represent it using a \cl{mpz\_t}.

Intermediate type system :
C-type with a flag : mutable (meaning that the expression it describes only has one pointer pointing to it.

\begin{lstlisting}
int a = 2;     a : int[mutable]
int* a = malloc( 10 * sizeof(int*) );  
\end{lstlisting}

destructive addition:

\begin{lstlisting}
d_add(*mpz_t res, mpz_t[mutable] a, long b) {
  mpz_add(a, a, b);
  (*res) = a;
}
\end{lstlisting}

Rq : \cl{d\_add} is given a mutable \mpzt, meaning that it can modify it and is responsible for freeing it.
It is also responsible for allocating memory for the result.
Here it uses the memory to assign res.



Use an intermediate language :

\begin{lstlisting}
( expr, C-type[mutable] )
\end{lstlisting}

Conversions and copies create mutables types (at a cost) :
\cl{a[mutable]\_from\_b}

\cite{fillcomp}







C types:\\
\cite{huss2004c}
\begin{lstlisting}[caption=C types]
// integer and floating point types
[unsigned] char, int, long, double
type*  //arrays
char*  // strings
struct types  // structures with fields
enum types
short int, float, union, size_t // etc...
\end{lstlisting}


Translation rules :

\begin{figure}[!ht]
\begin{tabular}{|l|l|}
\hline
\cl{subrange(a, b)} &
\begin{lstlisting}
int            // if small enough
unsigned long  // if too big or needed for function call
mpz_t          // else
\end{lstlisting} \\ \hline
\cl{int} &
\begin{lstlisting}
mpz_t
\end{lstlisting} \\ \hline
\cl{rat} &
\begin{lstlisting}
mpq_t
\end{lstlisting} \\ \hline
\cl{[below(a) -> Type]} &
\begin{lstlisting}
(Ctype)*
\end{lstlisting} \\ \hline
\cl{T : TYPE = [\# $x_i$ : $t_i$ \#]}  &
\begin{lstlisting}
struct CT {
   ...
   Ct_i x_i;
   ...
}; // These types must be declared
\end{lstlisting} \\ \hline
\cl{[Range -> Domain]} & C closure parameterized by the \cl{Domain} return type.\\ \hline
\end{tabular}
\caption{Translation rules for PVS types}
\end{figure}









We can only translate a subset of all PVS types.
What's missing ?




\subsection{Translating PVS syntax}


We can only translate a subset of PVS syntax.
What's missing ?



\subsection{Using a representation of the C language}

Figure~\ref{fig:Csyntax}




\section{Update expressions}


 It is a complicated problem to decide while compiling a functionnal language whether an update expression should be translated into a destructive or non destructive update in the target imperative language.\\

Update expressions are represented by PVS as \texttt{update-
expr} objects.

$$ E := \texttt{ t with [ e1 := e2 ] } $$

Problem :
\cl{t} is an expression typed as a function. Therefore it might be represented in C as an array (if domain type is \cl{below($n$)}.
We want to know if we can update \cl{t} in place to obtain a C object representing $E$ or if we have to make a copy of \cl{t}.


We consider a few solutions to this problem.


\subsection{Pointer counting}

Several systems rely on a reference couting garbage collectors. This family of garbage collectors has many advantages \cite{jonesgarbage}. Along with its simplicity and the instantaneity of garbage identification, the one we are interested in is the possibility to determine when a local variable is the only pointer to a complex data structure. In that case, at the cost of a simple test, we can avoid copies and perform destructive updates. \\

The idea is to keep track of the number of pointers pointing to an array or a struct. If an array is referenced in several portions of the code (nested reference in other data structure, local variable in calling function, ...) then we mus be able, using the pointer counter, to perform all updates non destructively to avoid inconsistency.\\

We implement a very simple "Reference Counting Garbage Collector" as described in \cite{jonesgarbage} and integrate it to the C code generated.\\

The GC consists on a hashtable of pointer counters that we maintain during the execution of the code. Each pointer to data allocated on the heap is a key in the hastable to which we associate an int counter as value. We then make sure that all memory allocations in the code make a call to the GC to "declare" the new memory.

\begin{tabular}{|p{5cm}|p{11cm}|}
\hline
\begin{lstlisting}
T* a = malloc(
     10 * sizeof(int));
\end{lstlisting} & \begin{lstlisting}
T* a = (T*) GC_malloc(10 * sizeof(int));
\end{lstlisting}
All memory allocation are handled by the GC to make sure every new reference on the heap is in the reference table and has a pointer counter associated to it.
\\ \hline
\begin{lstlisting}
free(a);
\end{lstlisting} & \begin{lstlisting}
GC_free(a);
\end{lstlisting}
This will decrement the reference counter on \cl{a} and might free it if this counter is now 0. \\ \hline
\begin{lstlisting}
T* a = b;
\end{lstlisting} & \begin{lstlisting}
T* a = (T*) GC( b );
\end{lstlisting}
The reference count on \cl{b} is incremented to represent that the local variable \cl{a} now also points to the structure \cl{b} points to.\\ \hline
\begin{lstlisting}
t[0] = b;
\end{lstlisting} & \begin{lstlisting}
GC_free( t[0] );
t[0] = (T*) GC( b );
\end{lstlisting}
This time, we also make sure the reference counter of \cl{t[0]} is decremented and \cl{t[0]} has a chance to be freed if nothing else points to it.\\ \hline
\end{tabular}

This requires to build our own C garbage collector \ref{fig:GC.h}.

\begin{figure}
\begin{lstlisting}
struct entry_s {
   void*  pointer;
   int    counter;
   struct entry_s *tl;
};
typedef struct entry_s* entry;

struct hashtable_s {
   int    size;
   entry* table;	
}; 
typedef struct hashtable_s* hashtable;

hashtable ht_create  ( int size );
int       ht_hashfunc( hashtable hashtable, void* pointer );
entry     ht_newentry( void* pointer );

hashtable GC_hashtable;
void      GC_start();
void      GC_quit();
entry     GC_get_entry( void* pointer );
void      GC_add_entry( entry e);
void      GC_new( void* pointer );
void*     GC( void* pointer );
int       GC_count( void* pointer );
void*     GC_malloc( int length, int size );
int       GC_free(void* pointer);
\end{lstlisting}
\caption{Garbage collector C header file: GC.h}
\label{fig:GC.h}
\end{figure}



\subsubsection{How to use it}

The garbage collector mus be used for every manipulation of pointers to memory allocated on the heap. This occurs typically when representing PVS arrays or data structure. These rrays are created in the code.\\

%% Deprecated example...
%\begin{lstlisting}
%int* f() {
%  int* res;
%  res = (int*) GC_alloc( 10 * sizeof(int) );
%  [... init res...]
%  return res; // pointer count = 1
%}
%
%void main() {
%   int* a = f();  // pointer counter of a = 1
%   int** b = (int**) GC_alloc( sizeof( int*) );
%   GC_free( b[0] );  // useless
%   b[0] = (int*) GC( a );  // pointer counter of a = 2
%   printf("f(0) = %s", b[0][0]);
%   GC_free(b); // frees b, pointer count of a = 1
%   GC_free(a); // frees a
%}
%\end{lstlisting}


When \cl{A} points to an array (or \cl{struct}) we want to update destructively, we first check if the pointer counter on \cl{A} is 1. If so, we can update in place because only the local variable \cl{A} points to the array.\\

However, we need to be carefull.
$$ \cl{g(A:Array) : int = f(A, A WITH [(0) := 3] )}$$
should not be translated to
\begin{lstlisting}
g(int* A) {
  A[0] = 3;
  return f(A, A);
}
\end{lstlisting}
for (at least) two reasons:
\begin{itemize}
\item The variable \cl{A} is updated destructively but it is later used as a reference to the previous value of the array.
\item \cl{f} is given twice a pointer to the same data structure. Its reference counter should be incremented.
\end{itemize}

Instead we could flatten the expression \ref{fig:exampleGC}.

\begin{figure}[!ht]
\begin{lstlisting}
void main() {
   GC_start();
   
   int* A = GC_malloc(10, sizeof(int) );  // Pointer counter of A = 1
   int i;
   for(i = 0; i < 10; i++)  // Initialisation of A
      A[i] = i;             // Here A = lambda(x):x
   int* B = g( GC(A) );     // We need A further, we make sure that g knows
   int* C = A;              // main still has a pointer to A
   printf("Pointers to C = %d", GC_count(C) ); // equal to 2
   GC_free(B); // Frees B
   GC_free(C); // Only decrement the counter of C
   GC_free(A); // Frees A (and C)
   GC_quit();
}

g(int* A) {
  int* arg1 = GC(A);           // A and arg1 now both point to the array
  int* arg2;
  if (GC(A) == 1)             // This is false
     arg2 = GC( A );
  else {                      // The update must be done non destructively
     arg2 = GC_malloc( 10, sizeof(int) );
     int i;
     for(i =0; i < 10; i++)
         arg2[i] = A[i];
  }  
  arg2[0] = 3;
  GC_free(A);                 // A is never used afterwards, we free it here
                              //(this requires an analysis of the C code)
  int* result = f(arg1, arg2);// A function is responsible for freeing its arguments
                              // (this is why we don't free arg1 and arg2)
  return result;
}
\end{lstlisting}
\caption{Example of the use of the GC}
\label{fig:exampleGC}
\end{figure}


But again, we are lucky here that \cl{A} is the first argument of \cl{f}. If the updated \cl{A} were the first arguments, the update would have been done destructively.
This is why the GC alone is not enoug. We need an analysis of the C code to determine whether a variable is goingto be used later in the code or not. cf \hyperref[Canalysis]{\ref*{Canalysis} Analysis of the C code}.


\subsubsection{Pros and cons}

The use of a garbage collector integrated in the C code seems like a good idea when translating a functionnal language to C. Using a pointer counting GC allows to 

We need an analysis of the C code for two reasons:
\begin{itemize}
\item To \cl{GC\_free} variable as soon as they are not needed anymore. Otherwise copies that could be avoided are performed because an other (useless) pointer still points to the structure we're interested in.
\begin{lstlisting}
  int* B = GC( A );
  update(B, 0, 1); // Can't be done destructively because A also points to
  GC_free(A);     // the same data as B
  f( GC(B) );     // f is given a variable with a reference counter of 2.
  GC_free( B );   // It might not be able to perform some update destructively
\end{lstlisting}
Should be
\begin{lstlisting}
  int* B = A;
  update(B, 0, 1);  // Can be done destructively
  f( B );           // f is given a variable with a reference counter of 1.
\end{lstlisting}
\item 
\end{itemize}

Every update require now tests and calls to hashtable functions. This is a small cost compared to the copying it may allow to avoid but no so small compared to a single in place update that could be decided by a code analysis.\\

Besides, the code gets much bigger since every update or copy requires the code to both destructive and non destructive operation and the if statement to decide which one to use.

Passing argument to function :
\begin{lstlisting}
int* f(int* arg) {
   int* result;
   if ( GC_count(arg) == 1)
      result = GC( arg );
   else {
      result = GC_malloc(10, sizeof(int));
      int i;
      for(i = 0; i < 10; i++)
         result[i] = GC( arg[i] );
   }
   GC_free(arg);
   result[0] = 3;
   return result;
}
\end{lstlisting}

This add quite some code compared to the simple :

\begin{lstlisting}
int* f(int* arg) {
   arg[0] = 3;
   return arg;
}
\end{lstlisting}




\subsection{Using a different data structure}

The Lisp code generated by PVS and used for example by the ground evaluator to compute PVS expressions represents PVS arrays with a more complex data structure than a simple array. It basically consists in an array and a replacement list. Every time an update on \cl{(A, l)} is performed, the result is a pointer to the same array \cl{A} and a replacement list with an extra term: \cl{(A, (0:=0) :: l)}. When the length of the list becomes too big, we create a new array \cl{A'} by applying the replacement terms to a copy of \cl{A} and we return \cl{(A', nil)}.\\

We could represent C data structure with a similar C structure. For example :
\begin{lstlisting}
struct r_list {
   int key;
   int value;
   r_list* tl;
};
struct array_int {
   int *data;
   r_list* replacement_list;
};
\end{lstlisting}

Each structure represent the array \cl{data} with the modifications contained in the linked list \cl{r\_list\_int}.\\

As in the previous solution, we have the following issues:
\begin{itemize}
\item This adds some extra code
\item This adds some extra computation. We need runtime tests for updates, and access to an element not requires reading the whole replacement list.
\item This relies on lot on the GC.
%\item This requires to create as many structures and associated functions as there are range types for the manipulated arrays.
\end{itemize}


\subsection{Flow analysis on the PVS code}

An other optimization would be to perform a analysis on the PVS variables to make sure an udate
Pavol \cite{pavol} suggests three analysis...



\subsection{Analysis of the C code}
\label{Canalysis}

This solution consist in performing an analysis on the C code internal representation before generating the actual output C code.\\

We use flags and two different version of the translated functions to translate update expressions (or dangerous function calls) into a destructive update as often as possible.\\


We define three flags:
\begin{itemize}
\item \bang means that the variable is the only pointer to the structure or array it points to. For instance if we have \cl{f(A:Arr):Arr = A WITH [(0) := 0]} then when \cl{f} is called in
$$ \cl{let A = lambda(x:int):x in let B = f(A) in B(0)} $$
we know that \cl{f} can update \cl{A} in place. We call the following version of \cl{f}.
\begin{lstlisting}
int* f(int* A) {
  A[0] = 0;
  return A;
}
\end{lstlisting}

\item \safe means that an occurrence of a variable is the last occurrence of that variable in the code. We need this flag to avoid updating destructively variables that appears later in the code. In the previous example, if we encounter
$$ \cl{let A = lambda(x:int):x in let B = f(A) in B(0) + A(0) }$$
we know we can't update \cl{A} destructively and we call instead a non-destructive version of \cl{f}:
\begin{lstlisting}
int* f(int* A) {
  int* res = malloc(...);
  for( i ...) res[i] = A[i];
  res[0] = 0;
  return res;
}
\end{lstlisting}

\item \dupl means that this expression may find itself nested in the result of the current function. For instance the identity function, \cl{id(A:Arr):Arr = A}, has its argument flagged \dupl. Therefore when \cl{id} is called we know that the result contains a pointer to its argument.
\begin{lstlisting}
...
int* A = malloc(...);
[ init A somehow ]
int* B = id(A);
\\ From now on B and A point to the same array
\\ For instance, A should probably not be modified in place
...
\end{lstlisting}
\end{itemize}

We want to ensure the following properties:

\begin{figure}
\begin{itemize}
\item Only function declarations and variables with type struct or array can be flagged \bang.
\item Only a single occurrence of a variable may be flagged \safe.
\item Only expressions and arguments can be flagged \dupl.
\item The last and only the last occurrence of a variable is flagged \safe.
\item Arguments of a non destructive function are never flagged \bang.
\item A function is flagged \bang iif its return variable is flagged \bang.
\item A variable may be flagged bang if it is created with a \cl{copy}, \cl{init\_array}, \cl{init\_record} or is the result of a call to a function flagged \bang.\\
It may not be flagged \bang if it is the result of a call to a function not flagged \bang.
\item A call to a destructive function \cl{f\_d( $a_i$, $b_j$, $c_k$ )} (where $a_i$ are flagged \bang and $b_j$ are flagged \dupl and $c_k$ are not flagged) may only occurs if the following conditions on the arguments passed $( A_i, B_j, C_k )$ are met:
\begin{itemize}
\item All $A_i$ are either calls to functions flagged \bang or variables flagged \bang and \safe.
\item All $B_j$ are either calls to functions or variables flagged \safe or not flagged \bang.
\item If the function call is flagged \dupl, then all $B_j$ are also flagged \dupl.
\end{itemize}
\item If a variable is once flagged \dupl, then if it is an argument, this argument is also flagged \dupl.
\end{itemize}
\caption{Propeties of the flags}
\label{fig:properties}
\end{figure}



\subsubsection{Algorithm}

Each PVS function is translated into two different C functions:
\begin{itemize}
\item A "cautious" non destructive version whose arguments are never \bang and therefore never modifies the arguments in place, always making copies when necessary. This doesn't mean this function can't make destructive update. For instance locally created arrays (using \cl{init\_array}) will be flagged \bang and might be destructively updated, should the conditions be met.
\item A destructive version which requires as many arguments as possible to be \bang and tries to do destructive updates as often as possible. This function only requires \bang arguments if it uses it destructively though.
\end{itemize}


\begin{figure}
\begin{lstlisting}
f(int* A, int* B) {         // A and B are both flagged duplicated
   if (A[0] == 0) {
      return B;
   } else {
      int* arg1 = copy(B);  // arg1 is flagged mutable and duplicated
      arg1[0] = arg1[0] - 1;
      f(arg1, A); // Both these occurrences of arg1 and A are flagged safe
   }
}

f_d(int* A, int* B) {  // A and B are both flagged mutable and duplicated
   if (A[0] == 0) {
      return B;
   } else {
      int* arg1 = B;    // No need to copy since B is mutable
                        // and never occurs afterwards
      arg1[0] = arg1[0] - 1;
      f_d(arg1, A);     // we can call f_d since the requirements are met:
   }                    //    both arg1 and A are flagged mutable
}
\end{lstlisting}
\caption{Example of the two different versions of a C function generated (stripped from GC instructions)}
\end{figure}




\begin{figure}
\begin{itemize}
\item Create the two versions of a function
\item Flag all arguments \bang in destructive version
\item Perform several passes and move flags to make sure the properties Figure~\ref{fig:properties} are verified.
\item Modify the code if the flags allow it according to the rules defined in the Annex~\ref{Rules}.
\item Redo the two previous steps until stabilization.
\end{itemize}
\caption{Algorithm}
\end{figure}





In destructive versions of all functions :
Flag all array arguments to "mutable".
Then for each of these arguments :
  - If it never occurs destructively, then remove flag
          (function just read the arg)
  - If it occurs destructively, it can never occur at all AFTER.
  -> Need to define the order of evaluation of expression
      (easy rules on simple expressions)
  -> Need to be able to detect occurences of a name-expr
  -> Otherwise, unflag the arg

A variable $V$ of type array is created in these cases:
\begin{itemize}
\item \cl{$V$ = $\lambda$x.e(x)} : $V$ has bang type
\item \cl{update($V$, $T$, key, value)} : $V$ has bang type because this is basically a copy and a destructive update.
\item \cl{f($V$,...) = ...} : type of $V$ depends on \cl{f}.
\end{itemize}
In these case, it has always bang type.\\
Or it can be set to an other referenced object.
\begin{itemize}
\item \cl{$V$ = $T$} $\rightarrow$ $V$ (should have bang type iff $T$ has !type too and never occurs afterwards). Happens in 
\item \cl{$V$ = $T$[i]} $\rightarrow$ depends on the target type of $T$.
\item \cl{$V$ = $T$.field} $\rightarrow$ depends on the type of the field.
\end{itemize}
At first all updates are non destructive.

First pass : All array variables (actuals and local variables) found in the code are flagged. Local variables are flagged according to the previous rules and actuals are flagged \textbf{mutable} in destructive version and \textbf{not mutable} in non-destructive versions. In functions returning an array (or record type), the variable result is also flagged.\\

Other passes :
Reading the code backwards, for every occurrence $T$ of a variable flagged \textbf{mutable}:
\begin{itemize}
\item If it is found in a \cl{$V$ = $T$} instruction, then we give the bang type to $V$ and remove bang type from $T$ so that previous occurrences of $T$ won't assume the uniqueness of the reference. This adds a new variable to the set of bang variables, hence the need to make several passes.
\item If it is used in a \cl{$V$ = copy($T$)} instruction, then we replace it with a \cl{$V$ = $T$} instruction and do as previous.
\item If it is found in an \cl{update($V$, $T$, i, e}, then turn that into \cl{$V$ = $T$; destr\_update($V$, i, e) }.
\item If it is a function call 
\item If we reach the declaration of a variable that is marked \textbf{mutable}, this means this variable is never read. In that case, we actually don't need it (unflag it I guess...).
\end{itemize}

At the end, when we have reached the transitive closure of this definition, if we reach the beginning of the function and some arguments are still bang, this means their bangness is never used, put the flag on that argument to \cl{non mutable} and remove the instructions freeing that variable (reminder : mutable arguments of a functions are freed inside the function or are used in a mutable way and appear somewhere in the result (trapped in closures) or are freed in other function calls.



\subsubsection{Algorithm}




All variables have three flags: $M$ (mutable), $D$ (duplicated) and $T$ (treated).

Init:\\
All arguments of a destructive function are flagged \cl{($M$ = true, $D$ = false, $T$ = true)}.\\
All arguments of a non destructive function are flagged \cl{($M$ = false, $D$ = false, $T$ = true)}.\\
All other variables are flagged \cl{($M$ = false, $D$ = false, $T$ = false)}.\\

Rules:\\
When $M$ is changed, $T$ is set to \cl{true}.\\
When $T$ is \cl{true}, the flag $M$ can only be set to \cl{false}.
This prevent infinite change of the flag $M$.\\
The flag $D$ can only be set to \cl{true}.\\



Initialization:\\


We initialize a set $M$ of mutable variables to all array arguments of a function $f$.
We also initialize a set $F$ of variables to free to $M$ since $f$ has the resposnability to free all variables flagged as mutable arguments.\\

We read the code backwards.\\
$T_i$ refer to variables that are in the set $M$.\\
$S_i$ refer to variables that are not in the set $M$.

\begin{tabular}{|p{60mm}|p{90mm}|}
\hline
\cl{$S$ = $T$} & $M \leftarrow M \cup \{ S \} - \{T\}$ \newline $F \leftarrow F \cup \{ S \} - \{T\}$  \\ \hline
\cl{$S$ = update($S_2$, key, value}) & $M \leftarrow M \cup \{ S \}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline
\cl{$S$ = update($T$, key, value}) & $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline

\cl{$S$ = g($T_i$, $S_i$}) & If the arguments of \cl{g} don't allow \cl{g} to be called destructively: \newline $M \leftarrow M - \{T_i \}$ \newline $M \leftarrow M \cup \{ S \}$ if return type of \cl{g} is \mut \newline $F \leftarrow F \cup \{ S\}$ \\ \hline

\cl{$S$ = g($T_i$, $S_i$}) & Otherwise: \newline \cl{$\rightarrow S$ = g\_d($T_i$, $S_i$} \newline $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline

\cl{$S$ = $S_2$[i]} & $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline


\end{tabular}




All arguments of the function are flagged \mut 




What is a destructive occurence :
$$ E :=  \cl{f(  t with [ e1 := e2 ] , t(0) )} $$
order of eval :
e1 and e2  (t can occur non destr)
t          ( expression of an update : destr)
t(0)       ( occurence of t (even non destr))

\cl{f(x:Arr):int = g( h(t), t)}  is destructively translated to \\
\begin{lstlisting}[numbers=left,caption=Example]
int f_d(int* t) {   // t has type ! since this is destructive f
  int* arg1 = h(t); // h can't be called destructively because
                    // even though t is !, it appears later (line 4)
  int* arg2 = t;    // t is ! and never appears later => arg2 is !
  return g( arg1, arg2); // arg2 is ! but g can only be called
}                        // destructively if arg1 is
\end{lstlisting}

if g has type \cl{[Array! -> ?]} then t can't be destructive\\

if g has type \cl{[Array -> ?]} then t can be destructive

First algorithm:


Need multiple passes as the flags disappear


\begin{figure}[!ht]
\begin{tabular}{|p{50mm}|p{62mm}|p{45mm}|}
\hline
\cl{update(A, key, value)} & \cl{A[key] = value;} & \cl{A} must be \mut \\ \hline
\cl{set(A, $expr$)} & \cl{A = $expr$;} \\ \hline
\cl{declare(A, $expr(i)$)} & \begin{lstlisting}
A = malloc(l * sizeof(T) );
int i;
for(i = 0; i < l; i++)
   A[i] = i + 1;
\end{lstlisting} & \\ \hline
\cl{copy(A, B)} & \begin{lstlisting}
A = malloc(l * sizeof(T) );
int i;
for(i = 0; i < l; i++)
   A[i] = B[i];
\end{lstlisting} & \\ \hline
\cl{init(A)} & \cl{int* A;} & \\ \hline
\cl{free(A)} & \cl{free(A);} & \\ \hline
\cl{base(str, (A, B, ...))} & \cl{int aux = A[0] + B[1];} & \cl{A} and \cl{B} are only read. \\ \hline
\cl{return} & \cl{return result;} & \\ \hline
\end{tabular}
\caption{C instructions}
\end{figure}



\begin{figure}[!ht]
\begin{tabular}{|p{50mm}|p{50mm}|p{50mm}|}
\hline
\cl{value($cste$)} & \cl{42} & \\ \hline
\cl{variable($type$, $name$)} & \cl{name} & \\ \hline
\cl{call(f, $exprs$)} & \cl{f( $expr_1$, $...$, $expr_n$ )} & \\ \hline
\end{tabular}
\caption{C expressions}
\end{figure}




\subsection{Combination of solutions}

We use the C code analysis to write some updates as destructive. However a few updates remain non destructive. For example:\\

If a function is called but requires its two argument to be \mut  and only the first is \mut. Then the non-destructive version is called and the first argument gets copied even though it was \mut.\\

If we perform an update on \cl{$T$[i]}, our analysis doesn't tell if \cl{$T$[i]} is \mut or \nmut.\\

To prevent that, we also perform a GC check. An update is actually a test wether an object is \mut or not and the appropriate update.






\newpage
\
\newpage

\section{Static analysis of the intermediate language}
\label{staticanal}

We describe here the static analysis of the intermediate language (which syntax is defined in Figure~\ref{fig:aux-syntax}) implemented in the translator.

\begin{figure}[!ht]
\input{includes/aux-expr}
\caption{Syntax of the intermediate language}
\end{figure}

We first define the semantics of the language using a small-steps operational semantics. Then we define a few operators on the language and exhibit some properties.
Finally we describe an algorithm to replace non destructive updates with destructive updates under certain conditions and prove that there is a bisimulation between programs before and after applying this algorithm. This proves that the execution of the program is not disturbed by the replacements and thus the correctness of the algorithm.



\subsection{Operational semantic}

A \emph{value} is either an integer $n \in \N$ or a reference $ref(i) \in R$. The metavariable $v$ ranges over the set of all values: $V := \N \cup R$.\\

An \emph{evaluation context} (sometimes simply called \emph{context}) $E$ is an expression with an occurrence of a hole $\econt{}$. A context  and is of one of the forms
\begin{enumerate}
\itemsep-0.2em
\item $\econt{}$
\item $\cl{set(} x \cl{, } \econt{} \cl{); } e $
\item $\cl{pop(} \econt{} \cl{)}$
\item $E1\econt{E2}$ \ \ , where E1 and E2 are evaluation contexts.
\end{enumerate}

A \emph{redex} is an expression of the following form
\begin{enumerate}
\itemsep-0.2em
\item $x$
\item $X[y]$
\item $\cl{if (} x \cl{) } a \cl{ else } b $
\item $\cl{array(} x \cl{)}$
\item $X\cl{[(} x \cl{) := } y \cl{]}$
\item $X\cl{[(} x \cl{) <- } y \cl{]}$
\item $\cl{lambda(}  f \cl{, } m \cl{, } x_1 \cl{, } ... \cl{, } x_m \cl{)}$
\item $y\cl{(} x_1 \cl{, } ... \cl{, } x_n \cl{)}$
\item $p\cl{(} x_1 \cl{, } ... \cl{, } x_n \cl{)}$
\item $f\cl{(} x_1 \cl{, } ... \cl{, } x_n \cl{)}$
\item $\cl{set(} x \cl{, } v \cl{); } e$
\item $\cl{pop( } v \cl{)}$
\end{enumerate}

We define a \emph{local environment}, $s_i$, as a function ranging over the set $N$ of all variable names with values in $V$.\\
The \emph{stack state}, $s$, is a series of local environments: $s = (s_0, ... , s_n)$.\\
We call $[]$ the empty function and if $s_i$ is a local environment ranging over the variables $U$, we write $s_i \uplus (x \mapsto v)$ the function ranging over $U \cup \{x\}$ mapping $x$ to $v$ and $y$ to $s_i(y)$ for $y \neq x$. For $s = (s_0, ... s_n)$ a stack state, we write $s \uplus (x \mapsto v) := \left( s_0 \uplus (x \mapsto v), s_1, ... , s_n \right)$. We also define $s(x)$ as $s_i(x)$ where $\forall j < i, s_j(x)$ is not defined and to simplify notations, we call $s' :: s := (s', s_0, ... , s_n)$ and even $s' :: S  := (s' :: s, h)$.

The \emph{heap state} function, $h$ is mapping references $ref(i)$ to arrays of values, $V*$.\\

The \emph{store} (or \emph{state}) function, $S$, describing the state of the memory at a certain point in the execution is defined as the couple $(s, h)$.\\
We define $S(x) := s(x)$ and $S(ref(i)) := h(ref(i))$.

A program is list of function declarations followed by a closed expression. For each function with id $f$ declared before the evaluation of the expression, we call $f_i$ the arguments of this function (variables) and $[f]$ its body (expression). A function is associated not only an id but also a number when declared. This number is used in lambda terms to refer to a function using a value.

The meta-variable conventions are that $x$ and $y$ range over variables, $X$ ranges over variables typed as arrays $n$ ranges over numbers, $p$ ranges over primitive function symbols, $f$ ranges over defined function symbols, $a$, $b$ and $e$ range over expressions. \\

A \emph{reduction} transforms a pair consisting of a redex and a store. The reductions corresponding to the redexes above are

\begin{enumerate}
\itemsep-0.2em
\item $<x,S> \ \longrightarrow \ < s(x), S> $
\item $<x \cl{[} y \cl{]} , S> \ \longrightarrow \ < h( s(x) )( s(y) ) , S >$
\item $<\cl{if (} x \cl{) } a \cl{ else } b, S>  \ \longrightarrow \ 
\left\lbrace \begin{array}{ll}
< \cl{pop(}a\cl{)} , [] :: S > & \text{if } s(x) = 0 \\
< \cl{pop(}b\cl{)} , [] :: S > & \text{otherwise}
\end{array} \right. $
\item $<\cl{array(} x \cl{)} , S > \ \longrightarrow \ < ref(m), (s , h' >$ where
\begin{eqnarray*}
h(ref(m)) & & \text{ is not defined  \ \ \ \ ($ref(m)$ is a fresh pointer)} \\
h' &=& h \uplus \left( ref(m) \mapsto (0)_{0 \leq i < s(x)} \right)
\end{eqnarray*}
\item $< X \cl{[(} x \cl{) := } y \cl{]} , S> \ \longrightarrow \ < ref(m), (s, h') >$ where
\begin{eqnarray*}
h(ref(m)) & & \text{ is not defined  \ \ \ \ ($ref(m)$ is a fresh pointer)} \\
h' &=& h \uplus \left( ref(m) \mapsto h( s(X) ) \uplus \left( s(x) \mapsto s(y) \right) \right)
\end{eqnarray*}
\item $< X \cl{[(} x \cl{) <- } y \cl{]} , S> \ \longrightarrow \ < X, (s, h') >$ where
\begin{eqnarray*}
h' &=& h \uplus \left( s(X) \mapsto h( s(X) ) \uplus \left( s(x) \mapsto s(y) \right) \right)
\end{eqnarray*}
\item $< \cl{lambda(} f \cl{, } m \cl{, } x_1 \cl{, } ... \cl{, } x_m \cl{)} , S > \ \longrightarrow \ < ref(m), (s, h') > $ where
\begin{eqnarray*}
h(ref(m)) & & \text{ is not defined  \ \ \ \ ($ref(m)$ is a fresh pointer)} \\
h' &=& h \uplus \left( ref(m) \mapsto \left| \begin{array}{ccl}
0 & \mapsto & k \ \ \text{such that $f$ is the $k$-th function declared.} \\
1 & \mapsto & m \\
i+1 & \mapsto & s(x_i) \ \text{ for } 1 \leq i \leq m \\
\end{array} \right. \right)
\end{eqnarray*}
\item $< y\cl{(} x_1 \cl{, } ... \cl{, } x_n \cl{)}, S> \ \longrightarrow \ < \cl{pop(} [f] \cl{)}, s' :: S>$ where
\begin{eqnarray*}
E & := & h( s(y) ) \\
f & & \text{is the $E(0)$-th function declared.} \\ 
m & := & E(1) \\
s' & : & \left| \begin{array}{ccl}
\{ f_1, ... , f_{m+n} \} & \rightarrow & V \\
f_i & \mapsto & E(i+1) \ \ \text{ for } i \leq m \\
f_{m+i} & \mapsto & s(x_i) \ \ \text{ for } i \leq n
\end{array} \right.
\end{eqnarray*}
\item $< p\cl{(} x \cl{, } y \cl{)}, S> \ \longrightarrow \ < p( s(x) , s(y) ), S>$ for binary operators.
\item $< p\cl{(} x \cl{)}, S> \ \longrightarrow \ < p( s(x) ), S >$ for the \cl{not} operator.
\item $<f\cl{(} x_1, ... , x_n \cl{)} , S> \ \longrightarrow \ < \cl{pop( } [f] \cl{)}, s' :: S > $ where
$$ s' = \biguplus_{1 \leq i \leq n} f_i \mapsto s(x_i) $$
\item $<\cl{set(} x \cl{, } v \cl{); } e, S> \ \longrightarrow \ < e, (s \uplus (x \mapsto v), h)> $
\item $<\cl{pop(} v \cl{)}, ( (s_0, ... , s_n), h) > \ \longrightarrow \ <v, ( (s_1, ... , s_n), h) > $
\end{enumerate}

An evaluation step operates on a pair $<e, S>$ consisting of a closed expression and a store, and is represented as $<e, S> \ \longrightarrow \ <e', S'>$. If $e$ can be decomposed as a $E\econt{a}$ for an evaluation context $E$ and a redex $a$, then a step $<E\econt{a}, S> \ \longrightarrow \ <E\econt{a'}, S'>$ holds if $<a, s> \ \longrightarrow \ <a', s'>$
This is represented by the following rule.
\begin{prooftree}
\AxiomC{$<a, s> \ \longrightarrow \ <a', s'>$}
\UnaryInfC{$<E\econt{a}, s> \ \longrightarrow \ <E\econt{a'}, s'>$}
\end{prooftree}
One of the greatest advantage of using evaluation contexts is that we define the semantics of this language using only two small-step rules. The evaluation context rule and the transitivity rule:
\begin{prooftree}
\AxiomC{$<a, s> \ \longrightarrow \ <b, s'>$}
\AxiomC{$<b, s'> \ \longrightarrow \ <c, s''>$}
\BinaryInfC{$<a, s> \ \longrightarrow \ <c, s''>$}
\end{prooftree}
The other advantage of using context is to be able to place critical expressions like updates into a context where the evaluation order is well defined and we can identify a few particular sets of variables.

The reflexive-transitive closure of $\longrightarrow$  is represented $ \longrightarrow^*$.
The computation of a program is defined as the evaluation of its expression $<e, S_0>$ on an empty store: $S_0 := (([]), [])$.
If $<e, S_0)> \longrightarrow^* <e', S'>$ then we can prove that $e' \in V$ and the result of the computation is then defined as $eval_{h'}(e')$ where $eval_h$ is defined as follow:
$$ eval_h : \left|
\begin{array}{ccl}
V &\longrightarrow & E \\
n &\mapsto& n \in \N \\
ref(k) &\mapsto& \left( eval_h(u_i) \right)_{0 \leq i \leq n} \text{ with } (u_i)_{0 \leq i < n} := h(ref(k))
\end{array}
\right. $$

\begin{theorem}
For all $<e, S_0> \ \longrightarrow \ <e', (s,h)>$, $h$ is defined on $R \cap Im(s)$. All references pointed to by a variable is defined in the heap stack.
\end{theorem}



\subsection{Update context}

We now define an \emph{update context} as an expression with a single occurence of a hole:
\begin{enumerate}
\itemsep-0.2em
\item $\ucont{}$
\item $\cl{set(} x \cl{, } U \cl{); } e $
\item $\cl{set(} x \cl{, } a \cl{); } U $
\item $ \cl{if (} x \cl{) } U \cl{ else } b $
\item $ \cl{if (} x \cl{) } a \cl{ else } U $
\end{enumerate}


We define the live variables, $Lv$, of an expression as
\begin{eqnarray*}
Lv( n ) & := & \emptyset \\
Lv( x ) & := & \{ x \} \\
Lv( X\cl{[}x\cl{]} ) & := & \{ X, x \} \\
Lv( \cl{if (} x \cl{) } a \cl{ else } b) & := & \{ x \} \cup Lv(a) \cup Lv(b) \\
Lv( \cl{array(} x \cl{)} ) & := & \{ x \} \\
Lv( X \cl{[(} x \cl{) := } y \cl{]} ) & := & \{ X, x, y \} \\
Lv( X \cl{[(} x \cl{) <- } y \cl{]} ) & := & \{ X, x, y \} \\
Lv( f(x_1 \cl{, } ... \cl{, } x_n) ) & := & \{ x_1, ... , x_n \} \\
Lv( p(x_1 \cl{, } ... \cl{, } x_n) ) & := & \emptyset \\
Lv( \cl{set(} x \cl{, } a \cl{); } e ) &:=& Lv(a) \cup \left( Lv(e) - \{ x \} \right)
\end{eqnarray*}

The variables live in a context are defined as:
\begin{eqnarray*}
Lv(\ucont{} ) &:=& \emptyset \\
Lv( \cl{set(} x \cl{, } U \cl{); } e ) &:=& Lv(U) \cup \left(Lv(e) - \{ x \} \right) \text{ where $U$ is an update context.} \\
Lv( \cl{set(} x \cl{, } a \cl{); } U ) &:=& Lv(U) \\
\cl{if (} x \cl{) } U \cl{ else } b &:=& Lv(U) \\
\cl{if (} x \cl{) } a \cl{ else } U &:=& Lv(U) 
\end{eqnarray*}


We also define the live cells, $Lc$, in an expression or update $e$ for a given store $S$.
\begin{eqnarray*}
Lc_0(S)(e) &:=& Lv(e) \\
Lc_{k+1}(S)(e) &:=& R \cap (Lc_k(S)(e) \cup S( Lc_k(S)(e) ) ) \\
Lc(S)(e) &:=& \lim_k Lc_k(S)(e) \subset R
\end{eqnarray*}
The live cells are the references that are accessible in a certain expression given a certain store $S$. All references that are not in this set do not have any influence on the evaluation of the expression.
It correspond to the references already created in the heap store that can still be accessed in the context or expression.

\begin{theorem}
If $<e_1, (s_1, h_1)> \ \longrightarrow \ <e_2, (s_2, h_2)>$ then $<e_1, (s_1, h'_1)> \ \longrightarrow \ <e_2, (s_2, h'_2)>$ where $h'_i = h_i|_{Lc(S_1)(e_1)}$.
\end{theorem}
\begin{proof}
It can easily be verified for every redex. When $a = U\ucont{b}$, we have $Lc(a) = Lc(U) \cup Lc(b)$ and the inductive step is proved .
\end{proof}


\subsection{Output variables}

We define the \emph{output} variables, $Ov$, of an expression:
\begin{eqnarray*}
Ov( n ) & := & \emptyset \\
Ov( x ) & := & \{ x \} \\
Ov( X\cl{[}x\cl{]} ) & := & \{ X \} \\
Ov( \cl{if (} x \cl{) } a \cl{ else } b ) & := & Ov(a) \cup Ov(b) \\
Ov( \cl{array(} x \cl{)} ) & := & \emptyset \\
Ov( X \cl{[(} x \cl{) := } y \cl{]} ) & := & \emptyset \\
Ov( X \cl{[(} x \cl{) <- } y \cl{]} ) & := & \{ X \} \\
Ov( f(x_1 \cl{, } ... \cl{, } x_n) ) & := & \{ x_i | f_i \in Ov([f]) \} \\
Ov( p(x_1 \cl{, } ... \cl{, } x_n) ) & := & \emptyset \\
Ov( \cl{set(} x \cl{, } a \cl{); } e ) &:=& Ov(e) - \{x\} \cup \left\lbrace \begin{array}{ll}
Ov(a) & \text{ if $x \in Ov(e)$.} \\
\emptyset & \text{ otherwise.}
\end{array} \right.
\end{eqnarray*}
This is the set of all variables which may have their value "trapped" into the expression.

\begin{theorem}
$Ov(e) \subset Lv(e)$. The output variables of an expression are live in that expression.
\end{theorem}
\begin{proof}
Simple induction proof on the expression form.
\end{proof}


We define the set $Dv(U)(z)$ of all variables that may contain a reference to $z$ in a certain context $U$:
\begin{eqnarray*}
Dv(\ucont{})(z) &:=& \{ z \} \\
Dv( \cl{set(} x \cl{, } U \cl{); } e ) &:=& Dv(U) \\
Dv( \cl{set(} x \cl{, } a \cl{); } U )(z) &:=& Dv(U)(z) \cup
  \left\lbrace \begin{array}{ll}
  \emptyset & \text{if } (Ov(a) \cup \{ x \}) \cap Dv(U)(z) = \emptyset \\
  (Ov(a) \cup \{ x \}) & \text{ otherwise.}
  \end{array} \right. \\
Dv(\cl{if (} x \cl{) } U \cl{ else } b) &:=& Dv(U) \\
Dv(\cl{if (} x \cl{) } a \cl{ else } U) &:=& Dv(U) 
\end{eqnarray*}

\subsubsection{Analysis}

We consider here that $f$ is a function which declaration doesn't contain any destructive update. The naive translation from PVS to this language only perform non destructive updates.

Intuitevely, if a function $f\cl{(}f_1\cl{, } ... \cl{, } f_n\cl{) = } e$ contains a non destructive update in a context $e = U\ucont{X\cl{[(}x\cl{) := }y\cl{]}}$. That update can be turned into a destructive update if the variables that may be aliased to $X$ are not live in the context.
$$ Dv(U)(X) \cap Lv(U) = \emptyset $$
This way all this variables that may point to $X$ are never used after the update. Since they are the only variables whose evaluation is modified by making hte update destructive, we can say that this is a safe transformation.\\

The problem is that some of these variables possibly pointing to $X$ might be included in the set of arguments of $f$: $\{f_1, ... , f_n\}$. And we can't assume anything about these variables since we don't have any information regarding the context in which the function $f$ is called.\\

We define two functions. A non destructive version $f$ with body $e_{nd}$ and a destructive version $f^d$ with body $e_d$.
Both new definitions only differ from the original body $e$ of $f$ in some substitution: non destructive updates in $e$ may be destructive in $e_{nd}$ and $e_d$ and some function calls to a function $g$ may become function calls to $g^d$ with the same arguments in $e_d$ and $e_{nd}$.\\

These functions use two different strategies:
\begin{itemize}
\item The second consists in allowing destructive updates of variables that could be aliased arguments. We however keep track of these arguments and only call this function when we are sure the arguments are safe in the context of the call. We define the $BA$ function on function declarations:
\begin{eqnarray*}
BA(f) &=& \bigcup_{e_d = U\ucont{X\cl{[(}x \cl{) <- } y \cl{]} }}  Dv(U)(X) \\
& \cup & \bigcup_{e_d = U\ucont{g\cl{(} x_1\cl{,} ... \cl{,} x_n \cl{)}}} Dv(U)( \{ x_i | g_i \in BA(g) \})
\end{eqnarray*}
The yields the definition $e_d$ of $f^d$ verifying the following properties:
\begin{itemize}
\item $\forall U, X, x, y$,
$$ e_d = U\ucont{X\cl{[(}x \cl{) <- } y \cl{]}} \ \ \Longrightarrow \ \  Dv(U)(X) \cap Lv(U) = \emptyset $$
\item $\forall U, g^d, (x_i)_{1 \leq i \leq n}$,
$$ e_d = U\ucont{g^d\cl{(}x_1 \cl{,} ... \cl{,} x_n \cl{)}} \ \ \Longrightarrow \ \  Dv(U)( \{ x_i | g^d_i \in BA(g^d) \}) \cap Lv(U) = \emptyset $$
\end{itemize}
\item The first consists in forbidding the use of destructive updates which argument may be pointing to by arguments. This is equivalent to saying that all arguments of non destructive functions are live in all contexts (or just in the empty context).
This yields the new definition $e_{nd}$ of $f$ verifying hte following properties:
\begin{itemize}
\item $\forall U, X, x, y$,
$$ e_{nd} = U\ucont{X\cl{[(}x \cl{) <- } y \cl{]}} \ \ \Longrightarrow \ \  Dv(U)(X) \cap \left( Lv(U) \cup \{f_1, ... , f_n \} \right) = \emptyset $$
\item $\forall U, g^d, (x_i)_{1 \leq i \leq n}$,
$$ e_d = U\ucont{g^d\cl{(}x_1 \cl{,} ... \cl{,} x_n \cl{)}} \ \ \Longrightarrow \ \  Dv(U)( \{ x_i | g^d_i \in BA(g^d) \}) \cap \left( Lv(U) \cup \{f_1, ... , f_n \} \right) = \emptyset $$
\end{itemize}
\end{itemize}
\begin{theorem}
For all non destructive version of a function $f$, $ BA(f) = \emptyset$.
\end{theorem}





\newpage
\subsection{Draft}

The translator from PVS to that intermediate language guarantees the following properties 
\begin{itemize}
\item All arguments passed to a function are \emph{different} variables.
\item Before the analysis, no destructive updates are used.
\end{itemize} 

For the need of the analysis, we enrich the state function with a reference counter $c:V \rightarrow \N$.


\begin{theorem}
If $<a, S>$ is \mut, and $<a, S> \ \longrightarrow <a', S'>$ then $<a', S'>$ is \mut.
\end{theorem}


A function $f$ is called \bang when
$$ Ov([f]) \cap \{ f_1, ... , f_n \} = \emptyset $$
This basically means that the output variables of any call to that function is the empty set.









\newpage
\section{Conclusion}


\subsection{Difficulties and successes}

This project was a great challenge and an opportunity for me to conduct my own research on a subject I chose. The development of the working translator was also 


\subsubsection{Working with new languages and tools}

To be able to translate PVS, I had to fully understand not only the syntax and semantics of the PVS language but also the structure of the PVS API written in Common Lisp. This means I also had to learn Common Lisp which I decided then to use to write the translator mostly because it made the integration of the native PVS parser and typechecker easier. Finally I had to discover the C language which I only had a basic knowledge of.


\subsubsection{Integrating the GMP library}
In PVS (and in other languages such as Common Lisp or Python), the \cl{integer} type represent the whole set $\Z$ of all relative numbers (and \cl{rational} also describe $\Q$).
To implement that in C, we need more than the finite types \cl{int}, \cl{long}, etc.

The translator uses the GMP library which introduces the types \mpzt and \mpqt. These types are pointers (technically arrays) to structures and they had to be used with caution (allocation, freeing, ...).

For example (Figure~\ref{fig:exGMP}), a function returning a \mpzt should actually take a first \mpzt argument and set it to the return value. Its return type being \cl{void}.

\begin{figure}[!ht]
\cl{norm(x:int, y:int):int = x*x + y*y}
\begin{lstlisting}
void norm(mpz_t result, mpz_t x, mpz_t y) {
  mpz_t aux1;
  mpz_init(aux1);
  mpz_mul(aux1, x, x);
  mpz_clear(x);
  mpz_t aux2;
  mpz_init(aux2);
  mpz_mul(aux2, y, y);
  mpz_clear(y);
  mpz_add(result, aux1, aux2);
  mpz_clear(aux1);
  mpz_clear(aux2);
}
\end{lstlisting}
\caption{Example of the GMP library use}
\label{fig:exGMP}
\end{figure}




\subsection{What's left to be done ?}

One of my biggest regret was not having the time to finish the translator and fully implement closures.
Some work is already done in that direction. We use a C structure to represent a closure:
\begin{lstlisting}
struct r_list_int {
   int (*body)(void* env, void* args);  // body is a function pointer
   void* env;                           // env contains the environment variables
   void* args;                          // args will contain the arguments
};
\end{lstlisting}



\subsection{My stay at SRI}

Besides the conception and implementation of the PVS to C compiler, my stay at SRI International was rich in interesting events.

The first weeks of my stay were the occasion to discover PVS and Coq as I started working on a translator Coq to PVS. With Robin, we also wrote as an exercise a basic linear algebra library.

I discovered Lisp the hard way while discovering the middle- and back-end of the PVS API. Among other excerises, I decided to write a Common Lisp parser to help me understand the huge architecture of the PVS API code (classes definitions, inheritances and organization, function dependances, ...)

I also have had the chance to attend to the many interesting seminars SRI hosted every week. The "Crazy Ideas" seminar hosted every other week was a ...

The SRI also organized a Summer School to which we were allowed to attend and which was very interesting.

Shankar never hesitated to include us in many project

I've been included in the HACMS project which was very interesting.
With other:
Correcting translator PVS to SMT-LIB




\subsubsection*{Draft}
Discovering PVS :
Translating Coq proofs to PVS
PVS library for basic linear algebra

Robin project, HACMS \\
Contest week-end 14-15 June \\
Summer School \\
Parsing Lisp code -> generate HTML architecture file\\
Correcting translator PVS to SMT-LIB
\cite{pavol}




\printbibliography

\appendix

\newpage
\section{PVS Syntax and CLOS representation}

\begin{figure}[h]
\input{includes/PVS-expr}
\caption{Syntax of the PVS subset of the translator}
\label{fig:PVSsyntax}
\end{figure}

\begin{figure}[!ht]
\input{includes/PVS-CLOS}
\caption{(Partial) CLOS representation of PVS syntax}
\label{fig:PVS-CLOS}
\end{figure}

\newpage
\section{PVS type system and CLOS representation}

\begin{figure}[!ht]
\input{includes/PVS-type}
\caption{Fragment of the PVS type system}
\label{fig:PVS-types}
\end{figure}


\begin{figure}[!ht]
\input{includes/PVS-CLOS-type}
\caption{(Partial) CLOS representation of PVS types}
\label{fig:PVS-CLOS-types}
\end{figure}


\newpage
\section{Intermediate languages}

\begin{figure}[!ht]
\input{includes/aux-expr}
\caption{Syntax of the intermediate language}
\label{fig:aux-syntax}
\end{figure}

\newpage
\begin{figure}[!ht]
\input{includes/C-expr}
\caption{Syntax of the representation language (representation of a subset of the C language)}
\label{fig:Csyntax}
\end{figure}



\newpage
\section{Rules}
\label{Rules}


\begin{figure}[!ht]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
             & \cl{A} \safe & \cl{A} not \safe \\ \hline
\cl{A} \mut  & Replace every occurence of the variable \cl{B} by the variable \cl{A} & \begin{lstlisting}
B = GC_malloc(...);
for(i ...) {
  B[i] = A[i];
}
\end{lstlisting} \\ \hline
\cl{A} \nmut & \begin{lstlisting}
if (GC_count(A) == 1) {
  B = A;
} else {
  B = GC_malloc(...);
  for(i ...) {
    B[i] = A[i];
  }
}
\end{lstlisting} & \begin{lstlisting}
B = GC_malloc(...);
for(i ...) {
  B[i] = A[i];
}
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Rules for \cl{copy(B, A)}}
\end{figure}



\begin{figure}[!ht]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
             & \cl{A} \safe & \cl{A} not \safe \\ \hline
\cl{A} \mut  & Replace every occurence of the variable \cl{B} by the variable \cl{A} & \begin{lstlisting}
B = GC_malloc(...);
for(i ...) {
  B[i] = A[i]
}
\end{lstlisting} \\ \hline
\cl{A} \nmut & Replace every occurence of the variable \cl{B} by the variable \cl{A} & \begin{lstlisting}
B = GC( A );
\end{lstlisting}
If \cl{B} is flagged \dupl then \cl{A} must be too.
\\ \hline
\end{tabular}
\caption{Rules for \cl{set(B, A)}}
\end{figure}



\begin{figure}[!ht]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
             & \cl{A} \safe & \cl{A} not \safe \\ \hline
\cl{A} \bang  &
\begin{lstlisting}
f_d(A)
\end{lstlisting} & \begin{lstlisting}
f(A)
\end{lstlisting} \\ \hline
\cl{A} not \bang & \begin{lstlisting}
f(A)
\end{lstlisting} & \begin{lstlisting}
f(A)
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Rules for \cl{f(A)} with \cl{A} flagged \bang in the destructive version}
\end{figure}


\begin{figure}[!ht]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
             & \cl{A} \safe & \cl{A} not \safe \\ \hline
\cl{A} \bang  &
\begin{lstlisting}
f(A)
\end{lstlisting} & \begin{lstlisting}
copy(B, A)
f(B)
\end{lstlisting} \\ \hline
\cl{A} not \bang & \begin{lstlisting}
f(A)
\end{lstlisting} & \begin{lstlisting}
f(A)
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Rules for \cl{f(A)} with \cl{A} flagged \dupl}
\end{figure}






\newpage
\section{Examples}


\begin{figure}[!ht]
\begin{tabular}{|p{5.2cm}|p{5.8cm}|p{6cm}|}
\hline
\begin{center}
PVS code
\end{center} &
\begin{center}
Intermediate language code
\end{center} &
\begin{center}
C code generated
\end{center} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr = A
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int*} \newline
\cl{set(result, A)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  return A;
}
\end{lstlisting} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr =
  let B = A in B
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int*} \newline
\cl{set(B, A)} \newline
\cl{set(result, B)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  return A;
}
\end{lstlisting} \\ \hline

\begin{lstlisting}
f(A:Arr):Cint =
 let B = A in
  A(0) + B(0)
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int} \newline
\cl{set(B, A)} \newline
\cl{set(result, +( A(0), B(0) ) )} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  int* B = (int*) GC( A );
  int result = A[0] + B[0];
  GC_free(B);
  GC_free(A);
  return result;
}
\end{lstlisting} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr =
  let B = A in
    A WITH [(0) := B(0) ]
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int} \newline
\cl{set(B, A)} \newline
\cl{set(L, 0)} \newline
\cl{set(R, B(0) )} \newline
\cl{update(result, A, L, R)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f_d(int* A) {
  int* B = GC_malloc(...);
  for(i ...)
     B[i] = A[i];
  int L = 0;
  int R = B[0];
  int* result = GC( A );
  result[L] = R;
  GC_free(B);
  GC_free(A);
  return result;
}
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Examples of setting variables}
\end{figure}


\begin{figure}[!ht]
\begin{tabular}{|p{5.5cm}|p{5.5cm}|p{6cm}|}
\hline
\begin{center}
PVS code
\end{center} &
\begin{center}
Intermediate language code
\end{center} &
\begin{center}
C code generated
\end{center} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr =
  A WITH [(0) := 0]
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int*} \newline
\cl{set(L, 0)} \newline
\cl{set(R, 0)} \newline
\cl{copy(result, A)} \newline
\cl{update(result, L, R)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  int L = 0, R = 0;
  int* result;
  if( GC_count(A) == 1 ) {
    result = GC( A );
  } else {
    result = GC_alloc(...);
    for(i ...)
      result[i] = A[i];
  }
  result[L] = R;
  GC_free( A );
  return result;
}

int* f_d(int* A) {
  int L = 0, R = 0;
  A[L] = R;
  return A;
}
\end{lstlisting} \\ \hline

\begin{lstlisting}
f(A:Arr):Arr =
 let B = A WITH[(0):=0]
 in A WITH[(0) := B(0)]
\end{lstlisting} &
\cl{f: ( (A, int*) ) -> int*} \newline
\cl{set(L1, 0)} \newline
\cl{set(R1, 0)} \newline
\cl{copy(B, A)} \newline
\cl{update(B, L1, R1)} \newline
\cl{set(L2, 0)} \newline
\cl{set(R2, B(0))} \newline
\cl{copy(result, A)} \newline
\cl{update(result, L1, R1)} \newline
\cl{return(result)} &
\begin{lstlisting}
int* f(int* A) {
  int R1 = 0, L1 = 0;
  B = GC_alloc(...);
  for(i ...)
    B[i] = A[i];
  B[L1] = R1;
  int R2 = 0, L2 = B[0];
  result = GC_alloc(...);
  for(i ...)
    result[i] = A[i];
  result[L2] = R2;
  GC_free(A);
  GC_free(B);
  return result;
}

int* f_d(int* A) {
  int R1 = 0, L1 = 0;
  B = GC_alloc(...);
  for(i ...)
    B[i] = A[i];
  B[L1] = R1;
  int R2 = 0, L2 = B[0];
  A[L2] = R2;
  GC_free(B);
  return A;
}
\end{lstlisting} \\ \hline
\end{tabular}
\caption{Examples of copying variables}
\end{figure}

\end{document}
