\documentclass[12pt,a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
% \usepackage[francais]{babel}

\usepackage[left=1.5cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage[colorlinks]{hyperref}
\usepackage{graphicx}

% --- CSL part
\usepackage{natbib}
\input{includes/pvstex}
\usepackage{includes/makebnf}


\usepackage[space]{grffile} % Celui-là je sais plus à quoi il sert...

% --- Partie code
\usepackage{listings}
\lstset{language=C} % Changer eventuellement le nom du langage
\newcommand{\codeline}[1]{\texttt{#1}}

% --- Parti math. (app.)
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{remark}[theorem]{Remark}

% Mathematic abbreviations

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Esp}{\mathbb{E}}
%\newcommand{\E}{\mathbb{E}} % Si tu l'utilise beaucoup
\newcommand{\Prob}{\mathbb{P}}
%\newcommand{\P}{\mathbb{P}} % Si tu l'utilise beaucoup

\newcommand{\mpzt}{\texttt{mpz\_t}}
\newcommand{\mpqt}{\texttt{mpq\_t}}

\title{
\vspace{-3cm}
\normalsize
\begin{tabular}{p{15cm}}
ÉCOLE POLYTECHNIQUE \\
PROMOTION X2011 \\
Férey Gaspard
\end{tabular}
\vspace{3cm}
\begin{center}
\includegraphics[height=3cm]{pictures/logo.png}
\end{center}
\vspace{1cm}
\large
\begin{center}
RAPPORT DE STAGE D'OPTION SCIENTIFIQUE\\
\vspace{1cm}
{\Huge Titre}\\
\vspace{1cm}
NON CONFIDENTIEL
\end{center}
\vspace{3cm}
\normalsize
\begin{tabular}{p{6cm} p{10cm}}
Option :                  & INFORMATIQUE \\
Champ de l'option :       & Math-Informatique \\
Directeur de l'option :   & Olivier Bournez \\
Directeur de stage :      & Olivier Bournez \\
Dates du stage :          & 7 avril - 22 aout 2014\\
Nom et adresse de l'organisme :  & SRI International \\
                          & Computer Science Laboratory (CSL) \\
                          & 333 Ravenswood Avenue \\
                          & Menlo Park, CA 94025-3493 \\
                          & United States
\end{tabular}
}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}


\section{SRI}

\subsection{The HACMS Project}

\subsection{PVS}

\subsection{Translating PVS}
\subsubsection{Parsing and typechecking PVS}
These two task we leave to PVS native parser and typechecker.

The parser generates objects representing the expressions of the theory.

We only convert a subset of PVS.
This subset is defined by a subset of expression objects we can translate.
The objective is, of course, to be able to translate the maximum of (if not all) PVS expression objects.

\subsubsection{Other translator}
- Common Lisp (native)
- Clean
- Yices




\section{Translating PVS Syntax}

\subsection{PVS Syntax}

We describe here the syntax of PVS and the objects system used to represent them in Lisp. Some slots of the classes are voluntarily omitted. For a full description of PVS parser representation, refer to \cite{PVS:api}.

\input{includes/bnf-expr-aux}




\begin{class}{expr}{abstract}{\classhln{syntax}}
{\slotidx{type} & the type of the expression}
\end{class}

\begin{class}{name}{mixin}{\classhln{syntax}}
{\slotidx{id} & the identifier \\
 \slotidx{actuals} & a list of actual parameters \\
 \slotidx{resolutions} & singleton}
This is a mixin for names, i.e., \texttt{name-expr}s, \texttt{type-name}s, etc.
\end{class}

\begin{class}{name-expr}{}{\classhln{name} \classhln{expr}}{}
\end{class}

\begin{class}{number-expr}{}{\classhln{expr}}{\slotidx{number} & a nonnegative integer}
\end{class}

\begin{class}{tuple-expr}{}{\classhln{expr}}{\slotidx{exprs} & a list of expressions}
\end{class}

\begin{class}{application}{}{\classhln{expr}}%
{\slotidx{operator} & an expr \\
 \slotidx{argument} & an expr (maybe a tuple-expr)}
\end{class}

\begin{class}{field-application}{}{\classhln{expr}}%
{\slotidx{id} & identifier \\
 \slotidx{actuals} & a list of actuals \\
 \slotidx{argument} & the argument}
A field application is the internal representation for record extraction,
e.g., \texttt{r`a}
\end{class}

\begin{class}{record-expr}{}{\classhln{expr}}{\slotidx{assignments} & a list of assignments}
\end{class}

\begin{class}{lambda-expr}{}{\classhln{binding-expr}}{}
This is the subclass of \texttt{binding-expr} used for LAMBDA expressions.
\end{class}

\begin{class}{if-expr}{}{\classhln{application}}{}
When an application has an operator that resolves to the \texttt{if\_def} it is changed to this class.
\end{class}

\begin{class}{update-expr}{}{\classhln{expr}}
{\slotidx{expression} & an expr \\
 \slotidx{assignments} & a list of assignments}
An update expression of the form \texttt{e WITH [x := 1, y := 2]}, maps to
an \texttt{update-expr} instance, where the \texttt{expression} is
\texttt{e}, and the \texttt{assignments} slot is set to the list of
generated \texttt{assigment} instances.  Note that these are very
succinct representations, but correspondingly difficult to typecheck or to
translate to other systems (e.g., decision procedures).  See the
description of the function \codeline{translate-update-to-if!} for more
 details.
\end{class}

\begin{class}{assignment}{}{\classhln{syntax}}
{\slotidx{arguments} & the list of arguments \\
 \slotidx{expression} & the value expression}
Assignments occur in both record-exprs and update-exprs.  The
\texttt{arguments} form is a list of lists.  For example, given the
assignment \texttt{`a(x, y)`1 := 0}, the \texttt{arguments} are
\texttt{((a) (x y) (1))} and the \texttt{expression} is \texttt{0}.
\end{class}



\subsection{Translator architecture}

Describe here the Lisp functions and data structures
Skeleton
Expected input
Output objects
Assertions that we (try to) maintain


\subsection{A few translation rule}

Translation rules :

\begin{lstlisting}
number-expr "2"
(C-int, "2", [], [])

number-expr "12315468453213"
(C-mpz, nil,
        [mpz_t ~a; | mpz_t_init("12315468453213"); ],
        [mpz_clear ~a;])

application "f(e1, e2)"
(C-mpz, nil,
       [ instr(e1) | instr(e2)
                   | mpz(~a); | f(~a, e1, e2) ]
       [mpz_clear(~a);]
\end{lstlisting}



\section{Types}

\subsection{PVS Types}
A PVS theory can be typechecked using the emacs interface \codeline{M-x typecheck} or with Lisp function \codeline{(tc name-theory)}. This first runs the PVS parser on the code and generates CLOS objects to represent it. Then, the PVS typechecker is run on this internal representation of the theory and tries to give a type to all expressions generating TCC when needed.\\

Here we describe how PVS types are represented in Lisp. The syntax of PVS we allow

\input{includes/bnf-type-expr}

\begin{class}{type-expr}{abstract}{\classhln{syntax}}
{}
\end{class}
\begin{class}{type-name}{}{\classhln{type-expr} \classhln{name}}
{\slotidx{adt} & }
\end{class}
\begin{class}{subtype}{}{\classhln{type-expr}}
{\slotidx{supertype} & \\
 \slotidx{predicate} & }
\end{class}
\begin{class}{funtype}{}{\classhln{type-expr}}
{\slotidx{domain} & \\
 \slotidx{range} & }
\end{class}
\begin{class}{tupletype}{}{\classhln{type-expr}}
{\slotidx{types} & }
\end{class}
\begin{class}{recordtype}{}{\classhln{type-expr}}
{\slotidx{fields} & }
\end{class}


\subsection{Translating types}
PVS types:\\
boolean, number, number\_field, real, 
rational, integer, $A \rightarrow B$, restricted types
$\text{below}(10) := \{ x:\text{int} | 0 \leq x < 10 \} $)  \\
enum
datatype



Auxiliary type system :
C-type with a flag : mutable (meaning that the expression it describes only has one pointer pointing to it.

\begin{lstlisting}
int a = 2;     a : int[mutable]
int* a = malloc( 10 * sizeof(int*) );  
\end{lstlisting}

destructive addition:

\begin{lstlisting}
d_add(*mpz_t res, mpz_t[mutable] a, long b) {
  mpz_add(a, a, b);
  (*res) = a;
}
\end{lstlisting}

Rq : \codeline{d\_add} is given a mutable \mpzt, meaning that it can modify it and is responsible for freeing it.
It is also responsible for allocating memory for the result.
Here it uses the memory to assign res.



Use an auxiliary language :

\begin{lstlisting}
( expr, C-type[mutable] )
\end{lstlisting}

Conversions and copies create mutables types (at a cost) :
\codeline{a[mutable]\_from\_b}









C types:\\
[unsigned] char, int, long, double
boolean
arrays
strings
enum
struct
and others: short int, float, union, size\_t, ...










We can only translate a subset of all PVS types.
What's missing ?




\subsection{Translating PVS syntax}


We can only translate a subset of PVS syntax.
What's missing ?



\section{Difficulties and successes}


\subsection{\texttt{if} expressions}
Represented by \texttt{if-expr}

\subsection{Integer, rationnals}
In PVS, the \texttt{integer} represent the whole set $\Z$ of all relative numbers (and \texttt{rational} also describe $\Q$).
In C, we have finite types
int, long, ...

We need the GMP library which introduces the types \mpzt and \mpqt.
These types are arrays and should be used just as integer (not as pointers except they still need to be freed).


\subsection{ Garbage collection }

We implement a very simple "Reference Counting Garbage Collector" as described in \cite{jonesgarbage}.\\

We maintain a hashtable of pointer counters.
Each pointer in the code is a key in the hastable to which we associate an int counter as value.\\

Pointers only occurs in arrays or struct.\\

Arrays are created in the code.\\


\begin{lstlisting}
T* a = b;
\end{lstlisting}
becomes
\begin{lstlisting}
T* a = GC( b ); // Should not happen often...
\end{lstlisting}

\begin{lstlisting}
t[0] = b;  // with b of type T*
\end{lstlisting}
becomes
\begin{lstlisting}
GC_free( t[0] );
t[0] = (T*) GC( b );
\end{lstlisting}

Examples

\begin{lstlisting}
int* f() {
  int* res;
  res = (int*) GC_alloc( 10 * sizeof(int) );
  [... init res...]
  return res; // pointer count = 1
}

void main() {
   int* a = f();  // pointer counter of a = 1
   int** b = (int**) GC_alloc( sizeof( int*) );
   GC_free( b[0] );  // useless
   b[0] = (int*) GC( a );  // pointer counter of a = 2
   printf("f(0) = %s", b[0][0]);
   GC_free(b); // frees b, pointer count of a = 1
   GC_free(a); // frees a
}
\end{lstlisting}



\subsection{ Update expressions }
Update expressions are represented by PVS as \texttt{update-expr} objects.

$$ E := \texttt{ t with [ e1 := e2 ] } $$


Problem :
\codeline{t} is an expression typed as a function. Therefore it might be represented in C as an array (if domain type is \codeline{below($n$)}.
We want to know if we can update \codeline{t} in place to obtain a C object representing \codeline{E} or if we have to make a copy of \codeline{t}.

Three solutions :

- Pointer counting :

We keep track of the number of pointer pointing to an array or a struct.

This requires to build our own C struct (heavy)
\begin{lstlisting}
struct array_int {
   int pointer_count = 1;
   int *data;
};
\end{lstlisting}

When we update the struct, if the pointer is 0, we update in place.\\

Besides every update require now to read the structure and make a test (small compared to a copy but no so small compared to a single in place update)\\

Besides, the creation / destruction gets more complicated\\

Passing argument to function :
\begin{lstlisting}
array_int f(array_int arg) {
   arg.pointer_count++;  \\ Since now f also have a pointer to the struct
   if (arg.pointer_count == 1) {
      arg.data[0] = 0;
      return arg;
   } else {
      array_int res;
      res.data = malloc( 10 * sizeof(int*) );
      copy(res, arg);  // Very long...
      res.pointer_count --; // This function is about to lose its pointer to res
      return res;
   }
}

void main() {
   array_int t;
   init(t);  // somehow...
   
   t.pointer_counter --;  // We assure we won't use the pointer "t" to the array anymore
   array_int r = f(t);
   t = null; // This way we garantee the variable "t" won't be used later in the code
   
   [...]   
}
\end{lstlisting}

This add quite some code compared to the simple :

\begin{lstlisting}
array_int f(array_int arg) {
   arg[0] = 0;
   return arg;
}

void main() {
   array_int t;
   init(t);  // somehow...
   array_int r = f(t);
   
   [...]   
}
\end{lstlisting}



- Using a different data structure

PVS uses arrays in a very particular way, we might then represent them with an other structure than just only a C array.
For example :

\begin{lstlisting}
struct r_list_int {
   int k;
   int v;
   r_list_int tl;
};

struct array_int {
   int *data;
   r_list_int replacement_list;
};
\end{lstlisting}

Each structure represent the array \codeline{data} with the modifications contained in the linked list \codeline{r\_list\_int}

Problems : Just as the previous solution :
- add some extra code
- add some extra computation (runtime tests)
- require to create as many structures and associated functions as there are range type fo the manipulated arrays


- Third solution :

Trying to avoid copying arrays by analyzing the code.
2 different functions (destructive and non destructive)


Algorithm :

Always have a "non destructive" version of any function. A "cautious" version that never modify the arguments in place and always make copies when necessary (when a "mutable" version of an array is necessary (for instance updates)).

In destructive versions of all functions :
Flag all array arguments to "mutable".
Then for each of these arguments :
  - If it never occurs destructively, then remove flag
          (function just observe the arg)
  - If it occurs destructively, it can never occur at all AFTER.
  -> Need to define the order of evaluation of expression
      (easy rules on simple expressions)
  -> Need to be able to detect occurences of a name-expr
  -> Otherwise, unflag the arg

What is a destructive occurence :
$$ E :=  \codeline{f(  t with [ e1 := e2 ] , t(0) )} $$
order of eval :
e1 and e2  (t can occur non destr)
t          ( expression of an update : destr)
t(0)       ( occurence of t (even non destr))

f( g(t), t)
if g has type [Array! -> ?] then t can't be destructive
if g has type [Array  -> ?] then t can be destructive

need multiple passes as the flags disappear





\subsection{Closures}

Nothing now


\section{Conclusion}

\subsection{What's left to be done ?}

\subsection{My stay at SRI}

Discovering PVS :
Translating Coq proofs to PVS
PVS library for basic linear algebra

Robin project, HACMS \\
Contest week-end 14-15 June \\
Summer School \\
Parsing Lisp code -> generate HTML architecture file\\
Correcting translator PVS to SMT-LIB




\bibliographystyle{plain}
\bibliography{report}


\end{document}
