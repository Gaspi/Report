\documentclass[12pt,a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
% \usepackage[francais]{babel}

\usepackage[left=1.5cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{graphicx}

% --- CSL part
\usepackage{natbib}
\input{includes/pvstex}
\usepackage{includes/makebnf}


\usepackage[space]{grffile}

% --- Partie code
\usepackage{listings}
\lstset{language=C,
        showstringspaces=false,
        basicstyle=\footnotesize\ttfamily,
        captionpos=b,
        stepnumber=1,
        keywordstyle=\bfseries\color{green!40!black},
        commentstyle=\itshape\color{purple!40!black},
        identifierstyle=\color{blue},
        stringstyle=\color{red}}

\newcommand{\cl}[1]{\texttt{#1}}

% --- Parti math. (app.)
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{remark}[theorem]{Remark}

% Mathematic abbreviations

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Esp}{\mathbb{E}}
%\newcommand{\E}{\mathbb{E}} % Si tu l'utilise beaucoup
\newcommand{\Prob}{\mathbb{P}}
%\newcommand{\P}{\mathbb{P}} % Si tu l'utilise beaucoup

\newcommand{\mpzt}{\texttt{mpz\_t}}
\newcommand{\mpqt}{\texttt{mpq\_t}}

\newcommand{\mut}{\textbf{mutable}}
\newcommand{\nmut}{\textbf{non-mutable}}


\title{
\vspace{-3cm}
\normalsize
\begin{tabular}{p{15cm}}
ÉCOLE POLYTECHNIQUE \\
PROMOTION X2011 \\
Férey Gaspard
\end{tabular}
\vspace{3cm}
\begin{center}
\includegraphics[height=3cm]{pictures/logo.png}
\end{center}
\vspace{1cm}
\large
\begin{center}
RAPPORT DE STAGE D'OPTION SCIENTIFIQUE\\
\vspace{1cm}
{\Huge Titre}\\
\vspace{1cm}
NON CONFIDENTIEL
\end{center}
\vspace{3cm}
\normalsize
\begin{tabular}{p{6cm} p{10cm}}
Option :                  & INFORMATIQUE \\
Champ de l'option :       & Math-Informatique \\
Directeur de l'option :   & Olivier Bournez \\
Directeur de stage :      & Olivier Bournez \\
Dates du stage :          & 7 avril - 22 aout 2014\\
Nom et adresse de l'organisme :  & SRI International \\
                          & Computer Science Laboratory (CSL) \\
                          & 333 Ravenswood Avenue \\
                          & Menlo Park, CA 94025-3493 \\
                          & United States
\end{tabular}
}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}


\section{SRI}

\subsection{The HACMS Project}

\subsection{PVS}

\subsection{Translating PVS}
\subsubsection{Parsing and typechecking PVS}
These two task we leave to PVS native parser and typechecker.

The parser generates objects representing the expressions of the theory.

We only convert a subset of PVS.
This subset is defined by a subset of expression objects we can translate.
The objective is, of course, to be able to translate the maximum of (if not all) PVS expression objects.

\subsubsection{Other translator}
- Common Lisp (native)
- Clean
- Yices




\section{Translating PVS Syntax}

\subsection{PVS Syntax}

We describe here the syntax of PVS and the objects system used to represent them in Lisp. Some slots of the classes are voluntarily omitted. For a full description of PVS parser representation, refer to \cite{PVS:api}.

\begin{figure}
\input{includes/bnf-expr-aux}
\caption{Syntax of the PVS subset of the translator}
\end{figure}


\begin{figure}
\begin{class}{expr}{abstract}{\classhln{syntax}}
{\slotidx{type} & the type of the expression}
\end{class}

\begin{class}{name}{mixin}{\classhln{syntax}}
{\slotidx{id} & the identifier \\
 \slotidx{actuals} & a list of actual parameters \\
 \slotidx{resolutions} & singleton}
This is a mixin for names, i.e., \texttt{name-expr}s, \texttt{type-name}s, etc.
\end{class}

\begin{class}{name-expr}{}{\classhln{name} \classhln{expr}}{}
\end{class}

\begin{class}{number-expr}{}{\classhln{expr}}{\slotidx{number} & a nonnegative integer}
\end{class}

\begin{class}{tuple-expr}{}{\classhln{expr}}{\slotidx{exprs} & a list of expressions}
\end{class}

\begin{class}{application}{}{\classhln{expr}}%
{\slotidx{operator} & an expr \\
 \slotidx{argument} & an expr (maybe a tuple-expr)}
\end{class}

\begin{class}{field-application}{}{\classhln{expr}}%
{\slotidx{id} & identifier \\
 \slotidx{actuals} & a list of actuals \\
 \slotidx{argument} & the argument}
A field application is the internal representation for record extraction,
e.g., \texttt{r`a}
\end{class}

\begin{class}{record-expr}{}{\classhln{expr}}{\slotidx{assignments} & a list of assignments}
\end{class}

\begin{class}{lambda-expr}{}{\classhln{binding-expr}}{}
This is the subclass of \texttt{binding-expr} used for LAMBDA expressions.
\end{class}

\begin{class}{if-expr}{}{\classhln{application}}{}
When an application has an operator that resolves to the \texttt{if\_def} it is changed to this class.
\end{class}

\begin{class}{update-expr}{}{\classhln{expr}}
{\slotidx{expression} & an expr \\
 \slotidx{assignments} & a list of assignments}
An update expression of the form \texttt{e WITH [x := 1, y := 2]}, maps to
an \texttt{update-expr} instance, where the \texttt{expression} is
\texttt{e}, and the \texttt{assignments} slot is set to the list of
generated \texttt{assigment} instances.
\end{class}

\begin{class}{assignment}{}{\classhln{syntax}}
{\slotidx{arguments} & the list of arguments \\
 \slotidx{expression} & the value expression}
Assignments occur in both record-exprs and update-exprs.\\
The \texttt{arguments} form is a list of lists.  For example, given the assignment \texttt{`a(x, y)`1 := 0}, the \texttt{arguments} are
\texttt{((a) (x y) (1))} and the \texttt{expression} is \texttt{0}.
\end{class}

\caption{(Partial) CLOS representation of PVS expressions}
\end{figure}


\subsection{Translator architecture}

Describe here the Lisp functions and data structures

Skeleton

Expected input

Output objects

Assertions that we (try to) maintain

Main steps :
\begin{itemize}
\item Typechecking: The PVS typechecker perform a type analysis on the PVS code to associate a PVS type to each expression. This might generates some proof obligations (TCC).
\item Lexical and syntactic analysis: The PVS parser transforms PVS code into a Lisp internal representation.
\item Translation: The translator generates a different representation from PVS expressions and functions declarations.
Typically, an expression $e$ is translated into a tuple of four elements $(t,n,i,d)$, where $t$ represents a C type used to describe the expression, $n$ is a string representing the expression, $i$ is a list of instructions supposed to be executed prior to using $n$ (initialisation of $n$) and $d$ is a list of instructions to be executed when $n$ isn't needed anymore (destruction of $n$).
\item Optimizations
\item Code generation: C code is generated.
\end{itemize}

We first define a function $T$ to translate an expression $e$.
$$ T(e) = ( \ T^t(e) \ , \ T^n(e) \ , \ T^i(e) \ , \ T^d(e) \ ) $$

\begin{figure}[h!]
\begin{eqnarray*}
T(\cl{2}) &= (& \cl{int}, "2", [], []) \\
T(\cl{4294967296}) &= (& \cl{mpz\_t}, \ ? \ , \\
&& [ \cl{mpz\_init(?);} \ | \\
&& \ \cl{mpz\_set\_str(?, "4294967296");} ],\\
&& [ \cl{mpz\_clear(?);} ]) \\
T(\cl{lambda(x:below(10)):x}) &= (& \cl{int*}, \ ? \ , \\
&& [ \cl{? = malloc(10 * sizeof(int));} \ | \\
&& \ \cl{int i;} | \\
&& \ \cl{for(i = 0; i < 10; i++) }\\
&& \ \ \ \cl{?[i] = i;}  ]\\
&& [ \cl{free(?);} ])
\end{eqnarray*}
\caption{Translation examples: number expressions}
\end{figure}

It may occur that $T^n(e) = ?$. In that case, the symbol $?$ appearing in $T^i(e)$ and $T^d(e)$ needs to be replaced by a proper variable name.\\

We then define two other operators:
\begin{itemize}
\item $R$ wich take an expression and a type and may add an extra conversion in the instructions to make sure its result has the expected type. Also the result of this function has a proper name.
\item $S$ which take an expression, a type and a name. It makes sure that the given variable (type + name) is set to a value representing the expression.
\end{itemize}




\subsection{A few translation rules}

Translation rules :




\begin{lstlisting}
number-expr "2"
(C-int, "2", [], [])

number-expr "12315468453213"
(C-mpz, nil,
        [mpz_t ~a; | mpz_t_init("12315468453213"); ],
        [mpz_clear ~a;])

application "f(e1, e2)"
(C-mpz, nil,
       [ instr(e1) | instr(e2)
                   | mpz(~a); | f(~a, e1, e2) ]
       [mpz_clear(~a);]
\end{lstlisting}



\section{Types}

\subsection{PVS Types}
A PVS theory can be typechecked using the emacs interface \cl{M-x typecheck} or with Lisp function \cl{(tc name-theory)}. This first runs the PVS parser on the code and generates CLOS objects to represent it. Then, the PVS typechecker is run on this internal representation of the theory and tries to give a type to all expressions generating TCC when needed.\\

Here we describe how PVS types are represented in Lisp.

\begin{figure}
\input{includes/bnf-type-expr}
\caption{Fragment of the PVS type system}
\end{figure}


\begin{figure}
\begin{class}{type-expr}{abstract}{\classhln{syntax}}
{}
\end{class}
\begin{class}{type-name}{}{\classhln{type-expr} \classhln{name}}
{\slotidx{adt} & }
\end{class}
\begin{class}{subtype}{}{\classhln{type-expr}}
{\slotidx{supertype} & \\
 \slotidx{predicate} & }
\end{class}
\begin{class}{funtype}{}{\classhln{type-expr}}
{\slotidx{domain} & \\
 \slotidx{range} & }
\end{class}
\begin{class}{tupletype}{}{\classhln{type-expr}}
{\slotidx{types} & }
\end{class}
\begin{class}{recordtype}{}{\classhln{type-expr}}
{\slotidx{fields} & }
\end{class}
\caption{(Partial) CLOS representation of PVS types}
\end{figure}

\subsection{Translating types}
PVS types:\\
boolean, number, number\_field, real, 
rational, integer, $A \rightarrow B$, restricted types
$\text{below}(10) := \{ x:\text{int} | 0 \leq x < 10 \} $)  \\
enum
datatype


This requires a type analysis to decide on the type of a PVS expression. For example the PVS \cl{int} type can be represented by the \cl{int}, \cl{unsigned long} or \cl{mpz\_t} C types. In that case, we study the range of the expression to decide which types are allowed to represent it. Then we take the context in which the expression appears to decide. For instance in
\begin{lstlisting}
incr(x:below(10)):int = x+1
\end{lstlisting}
the \cl{x} expression, result of the function \cl{incr} can always be represented by an \cl{int} or \cl{unsigned long} in C but we choose here to represent it using a \cl{mpz\_t}.

Auxiliary type system :
C-type with a flag : mutable (meaning that the expression it describes only has one pointer pointing to it.

\begin{lstlisting}
int a = 2;     a : int[mutable]
int* a = malloc( 10 * sizeof(int*) );  
\end{lstlisting}

destructive addition:

\begin{lstlisting}
d_add(*mpz_t res, mpz_t[mutable] a, long b) {
  mpz_add(a, a, b);
  (*res) = a;
}
\end{lstlisting}

Rq : \cl{d\_add} is given a mutable \mpzt, meaning that it can modify it and is responsible for freeing it.
It is also responsible for allocating memory for the result.
Here it uses the memory to assign res.



Use an auxiliary language :

\begin{lstlisting}
( expr, C-type[mutable] )
\end{lstlisting}

Conversions and copies create mutables types (at a cost) :
\cl{a[mutable]\_from\_b}

\cite{fillcomp}







C types:\\
\cite{huss2004c}
\begin{lstlisting}[caption=C types]
// integer and floating point types
[unsigned] char, int, long, double
type*  //arrays
char*  // strings
struct types  // structures with fields
enum types
short int, float, union, size_t // etc...
\end{lstlisting}


Translation rules :

\begin{figure}[h!]
\begin{tabular}{|l|l|}
\hline
\cl{subrange(a, b)} &
\begin{lstlisting}
int            // if small enough
unsigned long  // if too big or needed for function call
mpz_t          // else
\end{lstlisting} \\ \hline
\cl{int} &
\begin{lstlisting}
mpz_t
\end{lstlisting} \\ \hline
\cl{rat} &
\begin{lstlisting}
mpq_t
\end{lstlisting} \\ \hline
\cl{[below(a) -> Type]} &
\begin{lstlisting}
(Ctype)*
\end{lstlisting} \\ \hline
\cl{T : TYPE = [\# $x_i$ : $t_i$ \#]}  &
\begin{lstlisting}
struct CT {
   ...
   Ct_i x_i;
   ...
}; // These types must be declared
\end{lstlisting} \\ \hline
\cl{[Range -> Domain]} & C closure parameterized by the \cl{Domain} return type.\\ \hline
\end{tabular}
\caption{Translation rules for PVS types}
\end{figure}









We can only translate a subset of all PVS types.
What's missing ?




\subsection{Translating PVS syntax}


We can only translate a subset of PVS syntax.
What's missing ?



\subsection{Using a representation of the C language}

\begin{figure}
\input{includes/C-expr}
\caption{Syntax of the representation of the atrget language (subset of the C language)}
\end{figure}




\section{Difficulties and successes}


\subsection{\texttt{if} expressions}
Represented by \texttt{if-expr}

\subsection{Integer, rationnals}
In PVS, the \texttt{integer} represent the whole set $\Z$ of all relative numbers (and \texttt{rational} also describe $\Q$).
In C, we have finite types
int, long, ...

We need the GMP library which introduces the types \mpzt and \mpqt.
These types are arrays and should be used just as integer (not as pointers except they still need to be freed).

\subsection{Update expressions}
Update expressions are represented by PVS as \texttt{update-expr} objects.

$$ E := \texttt{ t with [ e1 := e2 ] } $$


Problem :
\cl{t} is an expression typed as a function. Therefore it might be represented in C as an array (if domain type is \cl{below($n$)}.
We want to know if we can update \cl{t} in place to obtain a C object representing \cl{E} or if we have to make a copy of \cl{t}.


We consider three solutions to this problem.

\subsubsection{Pointer counting}

A first solution would be to keep track of the number of pointers pointing to an array or a struct. The idea is that if an array is referenced in several portions of the code (nested reference in other data structure, local variable in calling function, ...) then all update must be done non destructively to avoid inconsistency.




We implement a very simple "Reference Counting Garbage Collector" as described in \cite{jonesgarbage}.\\

We maintain a hashtable of pointer counters.
Each pointer in the code is a key in the hastable to which we associate an int counter as value.\\

Pointers only occurs in arrays or struct.\\

Arrays are created in the code.\\

\begin{tabular}{|p{5cm}|p{11cm}|}
\hline
\begin{lstlisting}
T* a = malloc(
     10 * sizeof(int));
\end{lstlisting} & \begin{lstlisting}
T* a = (T*) GC_malloc(10 * sizeof(int));
\end{lstlisting}
All memory allocation are handled by the GC to make sure every new reference on the heap is in the reference table and has a pointer counter.
\\ \hline
\begin{lstlisting}
free(a);
\end{lstlisting} & \begin{lstlisting}
GC_free(a);
\end{lstlisting}
This will decrement the reference counter on \cl{a} and might free it if this counter is now 0. \\ \hline
\begin{lstlisting}
T* a = b;
\end{lstlisting} & \begin{lstlisting}
T* a = (T*) GC( b );
\end{lstlisting}
The reference count on \cl{b} is incremented to represent that the local variable \cl{a} now also points to the structure \cl{b} points to.\\ \hline
\begin{lstlisting}
t[0] = b;
\end{lstlisting} & \begin{lstlisting}
GC_free( t[0] );
t[0] = (T*) GC( b );
\end{lstlisting}
This time, we also make sure the reference counter of \cl{t[0]} is decremented and \cl{t[0]} has a chance to be freed if nothing else points to it.\\ \hline
\end{tabular}





Examples

\begin{lstlisting}
int* f() {
  int* res;
  res = (int*) GC_alloc( 10 * sizeof(int) );
  [... init res...]
  return res; // pointer count = 1
}

void main() {
   int* a = f();  // pointer counter of a = 1
   int** b = (int**) GC_alloc( sizeof( int*) );
   GC_free( b[0] );  // useless
   b[0] = (int*) GC( a );  // pointer counter of a = 2
   printf("f(0) = %s", b[0][0]);
   GC_free(b); // frees b, pointer count of a = 1
   GC_free(a); // frees a
}
\end{lstlisting}

This requires to build our own C struct (heavy)
\begin{lstlisting}
struct array_int {
   int pointer_count = 1;
   int *data;
};
\end{lstlisting}

When \cl{A} points to an array (or \cl{struct}) we want to update destructively, we first check if the pointer counter on \cl{A} is 1. If so, we can update in place because only \cl{A} points to the array.\\

However, we need to be carefull.
$$ \cl{g(A:Array) : int = f(A, A WITH [(0) := 3] )}$$
should not be translated to
\begin{lstlisting}
g(int* A) {
  A[0] = 3;
  return f(A, A);
}
\end{lstlisting}
for two reasons:
\begin{itemize}
\item The variable \cl{A} is updated destructively but it is later used as a reference to the previous value of the array.
\item \cl{f} is given twice a pointer to the same data structure. Its reference counter should be incremented.
\end{itemize}


Instead we could flatten the expression
\begin{lstlisting}
g(int* A) {
  int* arg1 = GC(A);           // A and arg1 now both point to the array
  int* arg2 = update(A, 0, 3); // cannot be done destructively
  int* result = f(arg1, arg2);
  GC_free(A); // A function is responsible for freeing its arguments
              // (this is why we don't free arg1 and arg2)
  return result;
}
\end{lstlisting}
But again, we are lucky here that \cl{A} is the first argument of \cl{f}. If the updated \cl{A} were the first arguments, the update would have been done destructively.
This is why the GC alone is not enoug. We need an analysis of the C code to determine whether a variable is goingto be used later in the code or not. cf \hyperref[Canalysis]{\ref*{Canalysis} Analysis of the C code}.


\subsubsection{Pros and cons}


Every update require now tests and calls to hashtable functions (small compared to the copy it allows to avoid but no so small compared to a single in place update that could be decided by a code analysis)\\

Besides, the creation / destruction gets more complicated\\

Passing argument to function :
\begin{lstlisting}
int* f(int* arg) {
   if ( GC_count(arg) == 1) {
      arg[0] = 3;
      return arg;
   } else {
      int* res;
      res = GC_malloc(10 * sizeof(int));
      int i;
      for(i = 0; i < 10; i++)
         res[i] = GC( arg[i] );
      GC_free(arg);
      res[0] = 3;
      return res;
   }
}
\end{lstlisting}

This add quite some code compared to the simple :

\begin{lstlisting}
int* f(int* arg) {
   arg[0] = 0;
   return arg;
}
\end{lstlisting}




\subsubsection{Using a different data structure}

PVS uses arrays in a very particular way, we might then represent them with an other structure than just only a C array.
For example :

\begin{lstlisting}
struct r_list {
   int key;
   int value;
   r_list tl;
};
struct array_int {
   int *data;
   r_list replacement_list;
};
\end{lstlisting}

Each structure represent the array \cl{data} with the modifications contained in the linked list \cl{r\_list\_int}

Problems : Just as the previous solution :
- add some extra code
- add some extra computation (runtime tests, reading the replacement list)
- require to create as many structures and associated functions as there are range types fo the manipulated arrays
- Very dependent on the GC


\subsubsection{Flow analysis on the PVS code}

An other optimization would be to perform a analysis on the PVS variables to make sure an udate
Pavol \cite{pavol} suggests three analysis...



\subsubsection{Analysis of the C code}
\label{Canalysis}



Trying to avoid copying arrays by analyzing the C code generated.

Each PVS function is translated into two different C functions: a safe non destructive version which and a destructive version.

The destructive version of a function may have some requirements on the counter of tits arguments. Its arguments may be flagged as \mut, meaning that every call to this version of the function must make sure that the arguments passed can be safely destructively updated.

Example (stripped from GC instructions)

\begin{lstlisting}
f(int* A, int* B) {
   if (A[0] == 0) {
      return B;
   } else {
      int* arg1 = copy(B);
      arg1[0] = arg1[0] - 1;
      f(arg1, A);
   }
}

f_d(int* A, int* B) {  // A and B are flagged mutable
   if (A[0] == 0) {
      return B;
   } else {
      int* arg1 = B;    // no need to copy since B is mutable
                        // and never occurs afterwards
      arg1[0] = arg1[0] - 1;
      f_d(arg1, A);
   }
}

\end{lstlisting}




Algorithm :

Always have a "non destructive" version of any function. A "cautious" version that never modify the arguments in place and always make copies when necessary (when a "mutable" version of an array is necessary (for instance updates)).

In destructive versions of all functions :
Flag all array arguments to "mutable".
Then for each of these arguments :
  - If it never occurs destructively, then remove flag
          (function just read the arg)
  - If it occurs destructively, it can never occur at all AFTER.
  -> Need to define the order of evaluation of expression
      (easy rules on simple expressions)
  -> Need to be able to detect occurences of a name-expr
  -> Otherwise, unflag the arg

A variable $V$ of type array is created in these cases:
\begin{itemize}
\item \cl{$V$ = $\lambda$x.e(x)} : $V$ has bang type
\item \cl{update($V$, $T$, key, value)} : $V$ has bang type because this is basically a copy and a destructive update.
\item \cl{f($V$,...) = ...} : type of $V$ depends on \cl{f}.
\end{itemize}
In these case, it has always bang type.\\
Or it can be set to an other referenced object.
\begin{itemize}
\item \cl{$V$ = $T$} $\rightarrow$ $V$ (should have bang type iff $T$ has !type too and never occurs afterwards). Happens in 
\item \cl{$V$ = $T$[i]} $\rightarrow$ depends on the target type of $T$.
\item \cl{$V$ = $T$.field} $\rightarrow$ depends on the type of the field.
\end{itemize}
At first all updates are non destructive.

First pass : All array variables (actuals and local variables) found in the code are flagged. Local variables are flagged according to the previous rules and actuals are flagged \textbf{mutable} in destructive version and \textbf{not mutable} in non-destructive versions. In functions returning an array (or record type), the variable result is also flagged.\\

Other passes :
Reading the code backwards, for every occurrence $T$ of a variable flagged \textbf{mutable}:
\begin{itemize}
\item If it is found in a \cl{$V$ = $T$} instruction, then we give the bang type to $V$ and remove bang type from $T$ so that previous occurrences of $T$ won't assume the uniqueness of the reference. This adds a new variable to the set of bang variables, hence the need to make several passes.
\item If it is used in a \cl{$V$ = copy($T$)} instruction, then we replace it with a \cl{$V$ = $T$} instruction and do as previous.
\item If it is found in an \cl{update($V$, $T$, i, e}, then turn that into \cl{$V$ = $T$; destr\_update($V$, i, e) }.
\item If it is a function call 
\item If we reach the declaration of a variable that is marked \textbf{mutable}, this means this variable is never read. In that case, we actually don't need it (unflag it I guess...).
\end{itemize}

At the end, when we have reached the transitive closure of this definition, if we reach the beginning of the function and some arguments are still bang, this means their bangness is never used, put the flag on that argument to \cl{non mutable} and remove the instructions freeing that variable (reminder : mutable arguments of a functions are freed inside the function or are used in a mutable way and appear somewhere in the result (trapped in closures) or are freed in other function calls.

\subsubsection{Algorithm}

Initialization:\\
We initialize a set $M$ of mutable variables to all array arguments of a function $f$.
We also initialize a set $F$ of variables to free to $M$ since $f$ has the resposnability to free all variables flagged as mutable arguments.\\

We read the code backwards.\\
$T_i$ refer to variables that are in the set $M$.\\
$S_i$ refer to variables that are not in the set $M$.

\begin{tabular}{|p{60mm}|p{90mm}|}
\hline
\cl{$S$ = $T$} & $M \leftarrow M \cup \{ S \} - \{T\}$ \newline $F \leftarrow F \cup \{ S \} - \{T\}$  \\ \hline
\cl{$S$ = update($S_2$, key, value}) & $M \leftarrow M \cup \{ S \}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline
\cl{$S$ = update($T$, key, value}) & $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline

\cl{$S$ = g($T_i$, $S_i$}) & If the arguments of \cl{g} don't allow \cl{g} to be called destructively: \newline $M \leftarrow M - \{T_i \}$ \newline $M \leftarrow M \cup \{ S \}$ if return type of \cl{g} is \mut \newline $F \leftarrow F \cup \{ S\}$ \\ \hline

\cl{$S$ = g($T_i$, $S_i$}) & Otherwise: \newline \cl{$\rightarrow S$ = g\_d($T_i$, $S_i$} \newline $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline

\cl{$S$ = $S_2$[i]} & $M \leftarrow M \cup \{ S \}  - \{T\}$ \newline $F \leftarrow F \cup \{ S \}$ \\ \hline


\end{tabular}




All arguments of the function are flagged \mut 




What is a destructive occurence :
$$ E :=  \cl{f(  t with [ e1 := e2 ] , t(0) )} $$
order of eval :
e1 and e2  (t can occur non destr)
t          ( expression of an update : destr)
t(0)       ( occurence of t (even non destr))

\cl{f(x:Arr):int = g( h(t), t)}  is destructively translated to \\
\begin{lstlisting}[numbers=left,caption=Example]
int f_d(int* t) {   // t has type ! since this is destructive f
  int* arg1 = h(t); // h can't be called destructively because
                    // even though t is !, it appears later (line 4)
  int* arg2 = t;    // t is ! and never appears later => arg2 is !
  return g( arg1, arg2); // arg2 is ! but g can only be called
}                        // destructively if arg1 is
\end{lstlisting}

if g has type \cl{[Array! -> ?]} then t can't be destructive\\

if g has type \cl{[Array -> ?]} then t can be destructive

First algorithm:


Need multiple passes as the flags disappear




\begin{figure}
\begin{tabular}{|p{50mm}|p{62mm}|p{45mm}|}
\hline
\cl{update(A, key, value)} & \cl{A[key] = value;} & \cl{A} must be \mut \\ \hline
\cl{set(A, $expr$)} & \cl{A = $expr$;} \\ \hline
\cl{declare(A, $expr(i)$)} & \begin{lstlisting}
A = malloc(l * sizeof(T) );
int i;
for(i = 0; i < l; i++)
   A[i] = i + 1;
\end{lstlisting} & \\ \hline
\cl{copy(A, B)} & \begin{lstlisting}
A = malloc(l * sizeof(T) );
int i;
for(i = 0; i < l; i++)
   A[i] = B[i];
\end{lstlisting} & \\ \hline
\cl{init(A)} & \cl{int* A;} & \\ \hline
\cl{free(A)} & \cl{free(A);} & \\ \hline
\cl{base(str, (A, B, ...))} & \cl{int aux = A[0] + B[1];} & \cl{A} and \cl{B} are only read. \\ \hline
\cl{return} & \cl{return result;} & \\ \hline
\end{tabular}
\caption{C instructions}
\end{figure}



\begin{figure}
\begin{tabular}{|p{50mm}|p{50mm}|p{50mm}|}
\hline
\cl{value($cste$)} & \cl{42} & \\ \hline
\cl{variable($type$, $name$)} & \cl{name} & \\ \hline
\cl{call(f, $exprs$)} & \cl{f( $expr_1$, $...$, $expr_n$ )} & \\ \hline
\end{tabular}
\caption{C expressions}
\end{figure}




\subsubsection{Combination of solutions}

We use the C code analysis to write some updates as destructive. However a few updates remain non destructive. For example:\\

If a function is called but requires its two argument to be \mut  and only the first is \mut. Then the non-destructive version is called and the first argument gets copied even though it was \mut.\\

If we perform an update on \cl{$T$[i]}, our analysis doesn't tell if \cl{$T$[i]} is \mut or \nmut.\\

To prevent that, we also perform a GC check. An update is actually a test wether an object is \mut or not and the appropriate update.




\section{Conclusion}

\subsection{What's left to be done ?}

Use a C structure to represent a closure
\begin{lstlisting}
struct r_list_int {
   int (*body)(void* env, void* args);
   void* env;
   void* args;
};
\end{lstlisting}



\subsection{My stay at SRI}

Besides the conception and implementation of the PVS to C compiler, my stay at SRI International was rich in ??? events.

The first days of my stay were the occasion to discover PVS anc Coq as I started working on a translator Coq to PVS. With Robin, we also wrote as an exercise a basic linear algebra library.

I discovered Lisp the hard way while learning how the back end of PVS worked. I've wrote a Lisp parser to help me see clear in the huge code (classes definitions, inheritances and organization, function dependances, ...)

I also have had the chance to attend to the many interesting seminars SRI hosted every week.
The SRI also organized a Summer School to which we were allowed to attend and which was very interesting.

Shankar never hesitated to include us in many project

I've been included in the HACMS project which was very interesting.
With other:
Correcting translator PVS to SMT-LIB




\subsubsection*{Draft}
Discovering PVS :
Translating Coq proofs to PVS
PVS library for basic linear algebra

Robin project, HACMS \\
Contest week-end 14-15 June \\
Summer School \\
Parsing Lisp code -> generate HTML architecture file\\
Correcting translator PVS to SMT-LIB
\cite{pavol}



\bibliographystyle{plain}
\bibliography{allbib}


\end{document}
